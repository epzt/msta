# -*- coding: utf-8 -*-
"""
/***************************************************************************
 msta
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsPoint
import numpy as np

# Trend operations
COMP = {
    'sup' : '>',
    'inf' : '<',
    'none' : ''
}

# Operand operations
OPERAND = {
    'ou' : 'OR',
    'et' : 'AND',
    'xou' : 'XOR',
    'none' : ''
}

# Unit of variables
UNIT = {
    '%' : 'percent',
    'm' : 'metre',
    'mm' : 'millimetre',
    'mu' : 'micronmetre',
    'phi' : 'phi',
    'other' : 'unknown'
}

#############################################################################
## class RANGE: manage variables range                                     ##
#############################################################################
'''
class RANGE():
    def __init__(self, _min, _max):
        self.min = _min
        self.max = _max

    def __repr__(self):
        return(f'min: {self.min} - max: {self.max}')

    def getMin(self):
        return self.min

    def getMax(self):
        return self.max

    def getDeltaRange(self):
        return(self.max - self.min)
'''
#############################################################################
## class ELLIPSE: manage variables search procedure                         ##
#############################################################################

class ELLIPSE():
    def __init__(self, _d, _t):
        self.direction = _d
        self.tolerance = _t

    def __eq__(self, _other):
        return self.direction == _other.getDirection() and self.tolerance == _other.getTolerance()

    def getDirection(self):
        return self.direction

    def getTolerance(self):
        return self.tolerance

    def isCircular(self, _r):
        return _r == self.tolerance

#############################################################################
## class mstaPoint: manage data points                                     ##
#############################################################################

class mstaPoint(QgsPoint):
    def __init__(self, _x, _y):
        """Constructor."""
        super().__init__(_x,_y)
        self.ID = 0
        self.variables = [] # List of mstaVariable type

    def __repr__(self):
        return(f'ID: {self.ID}, {super().asWkt()}\n\t{[i for i in  self.variables]}')

    def setID(self,_ID):
        self.ID = _ID

    def getID(self):
        return self.ID

    def getVariables(self):
        return self.variables

    def updateVariable(self, _newVar):
        for v in self.variables:
            if v.getName() == _newVar.getName():
                # Backup the value of the variable for this point because this is the only field
                # the user cannot change/modify
                _newVar.setValue(v.getValue())
                # Delete the variable to update in the list
                del self.variables[self.variables.index(v)]
                # Append the updated variable
                self.variables.append(_newVar)
                return

    def addVariable(self, _newvar):
        # Check if _newvar is still present the variable list at this point
        #if _newvar in self.variables and not isinstance(mstaVariable, _newvar):
        if _newvar in self.variables:
            return False
        self.variables.append(_newvar)
        return(True)

    def getVariableByName(self, _varname):
        retValue = None
        for i in self.variables:
            if i.getName() == _varname:
                retValue = i
                break
        return retValue

    def getVariableByID(self, _varid):
        retValue = None
        for i in self.variables:
            if i.getID() == _varid:
                retValue = i
                break
        return retValue

    def getVariableValueByName(self, _varname):
        self.getVariableByName(_varname).getValue()

    def getVariableValueByID(self, _varid):
        self.getVariableByID(_varid).getValue()


#############################################################################
## class mstaVariable: manage variable                                     ##
#############################################################################
class mstaVariable():
    def __init__(self):
        """Constructor."""
        self.ID = 0
        self.name = ""
        self.alias = ""
        self.unit = "%" #Default value, i.e. percent
        self.value = 0.0
        self.dg = 0.0
        self.range = 0.0 # +/- range centred around value
        self.search = ELLIPSE(0.0,self.dg) # By default circle search

    # Default operations
    # + addition
    def __add__(self,_other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        res.setRange(self.getRange()+self._other.getRange())
        res.setValue(self.getValue()+_other.getValue())
        return res
    def __iadd__(self,_other):
        self.range = self.getRange()+self._other.getRange()
        self.value = self.value+_other.getValue()
        return self
    # - substraction
    def __sub__(self,_other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        self.setRange(self.getRange()+self._other.getRange())
        res.setValue(self.getValue()-_other.getValue())
        return res
    def __isub__(self,_other):
        self.range = self.getRange()+self._other.getRange()
        self.value = self.value-_other.getValue()
        return self
    # * multiplication
    def __mul__(self,_other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        res.range = (_other.getValue()*self.getRange())+(self.getValue()*_other.getRange())
        res.setValue(self.getValue()*_other.getValue())
        return res
    def __imul__(self,_other):
        self.range = (_other.getValue()*self.getRange())+(self.getValue()*_other.getRange())
        self.setvalue = self.value*_other.getValue()
        return self
    # / division
    def __truediv__(self, _other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        res.range = (1/_other.getValue())*(self.getRange()+(self.getValue()/_other.getgetValue()*_other.getRange()))
        res.setValue(self.getValue() / _other.getValue())
        return res
    def __itruediv__(self, _other):
        self.range = (1/_other.getValue())*(self.getRange()+(self.getValue()/_other.getgetValue()*_other.getRange()))
        self.value = self.value / _other.getValue()
        return self
    # == equality
    def __eq__(self,_other):
        if self.isInRange(_other.getValue()) or _other.isInRange(self.getValue()):
            return True
        else:
            return False
    # != non equility
    def __ne__(self,_other):
        if not self.isInRange(_other.getValue()) and not _other.isInRange(self.getValue()):
            return True
        else:
            return False
    # < lower than
    def __lt__(self,_other):
        return(self.getMax() < _other.getMin())
    def __le__(self,_other):
        return(self.getMax() <= _other.getMin())
    # > upper thn
    def __gt__(self,_other):
        return(self.getMin() > _other.getMax())
    def __ge__(self,_other):
        return(self.getMin() >= _other.getMax())

    # Print itself
    def __repr__(self):
        return(f'Name: {self.name}, alias: {self.alias}\n \
                distance: {self.dg}, unit: {self.unit}\n \
                range: +/-{self.getRange()}\n \
                dir : {self.getDirection()}, Tol: {self.getTolerance()}')

    # Test if the current variable as same Dg, direction and tolerance than variable _other
    # convenient during process
    def isEqual(self, _other):
        return self.dg == _other.dg and self.getSearch() == _other.getSearch()

    def setID(self,_ID):
        self.ID = _ID
    def getID(self):
        return self.ID

    def setName(self,_name):
        self.name = _name
    def getName(self):
        return self.name

    def setAlias(self,_alias):
        self.alias = _alias
    def getAlias(self):
        return self.alias

    def setUnit(self,_unit):
        assert _unit in UNIT.keys()
        self.unit = _unit
    def getUnit(self):
        return self.unit

    def setValue(self,_value):
        self.value = _value
    def getValue(self):
        return self.value

    def getMin(self):
        return self.value - self.getRange()
    def getMax(self):
        return self.value + self.getRange()

    def setSearch(self,_d, _t):
        self.search = ELLIPSE(_d,_t)
    def getSearch(self):
        return self.search

    def getDirection(self):
        return self.search.getDirection() # Direction is stored as the first element of the list
    def getTolerance(self):
        return self.search.getTolerance() # Tol. angle is stored as the second element of the list

    def setDg(self, _dg):
        self.dg = _dg
    def getDg(self):
        return self.dg

    def setRange(self, _pm):
        self.range = _pm
    def getRange(self):
        return self.range

    def isInRange(self, _value):
        return(_value >= self.getMin() and _value <= self.getMax())

    # Return False only for phi units and other (not affected)
    def isMetric(self):
        return not (self.getUnit() == 'phi' or self.getUnit() == 'other')

#############################################################################
## class mstaTrendCase: manage trend case                                  ##
#############################################################################
class mstaTrendCase():
    def __init__(self, _variable):
        """Constructor."""
        self.ID = -1
        self.compSigne = COMP['none']
        assert _variable
        # Normally one case should be defined for same variable but
        # it is eventually possible to manage 2 different variables
        if isinstance(_variable, list):
            assert len(_variable) == 2
            self.leftVar = _variable[0]
            self.rightVar = _variable[1]
        else:
            self.leftVar = _variable
            self.rightVar = _variable

    # Print itself
    def __repr__(self):
        if self.compSigne != '':
            return (f'{self.leftVar.getAlias()}(i) {self.compSigne} {self.rightVar.getAlias()}(j)')

    def getTrendText(self):
        return (f'{self.leftVar.getAlias()}(i) {self.compSigne} {self.rightVar.getAlias()}(j)')

    # define equality or not between two mstaTrendCase objects
    def __eq__(self,_other):
        if self.getLeftVar().getName() == _other.getLeftVar().getName() and \
           self.getRightVar().getName() == _other.getRightVar().getName() and \
           self.getComp() == _other.getComp():
            return True
        else:
            return False

    def getID(self):
        return self.ID

    def setID(self, _id):
        assert _id >= -1
        self.ID = _id

    def setComp(self, _op):
        assert _op != ''
        self.compSigne = COMP[_op]

    def getComp(self):
        return(self.compSigne)

    def setLeftVar(self, _var):
        assert isinstance(_var, mstaVariable)
        self.leftVar = _var

    def getLeftVar(self):
        return self.leftVar

    def setRightVar(self, _var):
        assert isinstance(_var, mstaVariable)
        self.rightVar = _var

    def getRightVar(self):
        return self.rightVar

#############################################################################
## class mstaComposedTrendCase: manage trend case                          ##
#############################################################################
class mstaComposedTrendCase():
    def __init__(self):
        """Constructor."""
        self.ID = -1
        self.linkOperand = []
        self.trendList = []
        self.level = 1  # Define the level of the composed trend, must be in {1,2}

    def __getitem__(self, item):
        assert len(self.trendList) > 0
        if item < len(self.trendList):
            return self.trendList[item]
        else:
            return None

    def __repr__(self):
        if len(self.trendList) == 0:
            return
        return([t.__repr__() for t in self.trendList])

    def getTrendsText(self):
        retValue = []
        for t in self.trendList:
            if isinstance(t, mstaTrendCase):
                retValue.append(f'{t.getTrendText()}')
        return retValue

    # Equality between two mstacomposedtrendcase objects
    def __eq__(self,_other):
        if self.getTrend() == _other.getTrend():
            return True
        else:
            return False

    def getID(self):
        return self.ID

    def setID(self, _id):
        assert _id >= 0
        self.ID = _id

    # return the higher ID of mstaTrendCase object in the list
    def getMaxCaseID(self):
        maxID = -1  # just to be sure to get the max, even if not trend is defined (should be -1)
        for t in self.trendList:
            assert isinstance(t, mstaTrendCase)
            if maxID < t.getID():
                maxID = t.getID()
        return maxID

    def getLevel(self):
        return self.level

    def setLevel(self, _lvl):
        self.level = _lvl

    def addOperand(self, _op):
        self.linkOperand.append(OPERAND[_op])

    # Change the operand between two
    def setOperand(self, _id, _op):
        assert _id < len(self.linkOperand) and _id < len(self.trendList)-1
        self.linkOperand[_id] = OPERAND[_op]

    def getTrend(self, *args):
        if len(args) > 0:
            _id = args[0]
            assert _id < len(self.trendList)
            return self.trendList[_id]
        else:
            return self.trendList

    def getFirstTrend(self):
        assert len(self.trendList) >= 1
        return self.trendList[0]

    def getLastTrend(self):
        assert len(self.trendList) >= 1
        return self.trendList[-1]

    def getTrendCount(self):
        return len(self.trendList)

    def addTrendCase(self, _trendcase, _operand):
        assert isinstance(_trendcase, mstaTrendCase) or isinstance(_trendcase, mstaComposedTrendCase)
        # if more than one trend case
        #if len(self.trendList) > 0:
        #    assert OPERAND[_operand] # is _operand valid

        self.trendList.append(_trendcase)
        self.linkOperand.append(OPERAND[_operand])
        # there must be (operand + 1) trend cases
        # assert len(self.trendList) == len(self.linkOperand) + 1

    def deleteTrendCase(self, _trendcase):
        assert isinstance(_trendcase, mstaTrendCase) or isinstance(_trendcase, mstaComposedTrendCase)
        # if more than one trend case
        #if len(self.trendList) > 0:
        #    assert OPERAND[_operand] # is _operand valid
        for t in self.trendList:
            if t == _trendcase:
                index = self.trendList.index(t)
                assert index < len(self.linkOperand)
                if index == 0: # This is the first trend of the list
                    del self.linkOperand[0] # First element of operand list
                else:
                    del self.linkOperand[index-1]
                self.trendList.remove(t)
        return


   