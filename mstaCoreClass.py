# -*- coding: utf-8 -*-
"""
/***************************************************************************
 msta
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import (QgsPoint, QgsVectorLayer, QgsEllipse,
                       QgsGeometry,
                       QgsFeatureRequest,
                       QgsProcessing,
                       QgsExpression)
import numpy as np
import itertools as it

from . import config as cfg

#############################################################################
## class RANGE: manage variables range                                     ##
#############################################################################
'''
class RANGE():
    def __init__(self, _min, _max):
        self.min = _min
        self.max = _max

    def __repr__(self):
        return(f'min: {self.min} - max: {self.max}')

    def getMin(self):
        return self.min

    def getMax(self):
        return self.max

    def getDeltaRange(self):
        return(self.max - self.min)
'''
#############################################################################
## class ELLIPSE: manage variables search procedure                         ##
#############################################################################

class ELLIPSE():
    def __init__(self, _M, _m, _d=0):
        self.major = _M
        self.minor = _m
        self.direction = _d # Direction is stored in degrees

    def __repr__(self):
        if self.isCircle():
            return "Dg: {}".format(self.getMajor())
        else:
            return "M: {}, m: {}, D: {}".format(self.getMajor(), self.getMinor(), self.getDirection())

    def __eq__(self, _other):
        return self.direction == _other.getDirection() and self.major == _other.getMajor() and self.minor == _other.getMinor()

    def getDirection(self):
        return self.direction

    def setDirection(self, _d):
        assert _d >= 0.0 and _d <= 360.0
        self.direction = _d

    def getDirectionRadian(self):
        return np.deg2rad(self.direction)

    def getMajor(self):
        return self.major

    def getMinor(self):
        return self.minor

    def isCircle(self):
        return self.major == self.minor

#############################################################################
## class mstaPoint: manage data points                                     ##
#############################################################################

class mstaPoint(QgsPoint):
    def __init__(self, _x, _y):
        """Constructor."""
        super().__init__(_x, _y)
        self.ID = 0
        self.variables = [] # List of mstaVariable type

    def __repr__(self):
        return(f'ID: {self.ID}, {super().asWkt()}\n\t{[i for i in  self.variables]}')

    def setID(self, _ID):
        self.ID = _ID

    def getID(self):
        return self.ID

    def getVariables(self):
        return self.variables

    def updateVariable(self, _newVar):
        for v in self.variables:
            if v.getName() == _newVar.getName():
                # Backup the value of the variable for this point because this is the only field
                # the user cannot change/modify
                #_newVar.setValue(v.getValue())
                # Replace the variable with the new one in the list
                #self.variables[self.variables.index(v)] = _newVar
                v.setAlias(_newVar.getAlias())
                v.setUnit(_newVar.getUnit())
                v.setSearch(_newVar.getSearch().getMajor(), _newVar.getSearch().getMinor(), _newVar.getSearch().getDirection())
                v.setDg(_newVar.getDg())
                v.setRange(_newVar.getRange())
        return True

    def addVariable(self, _newvar):
        # Check if _newvar is still present the variable list at this point
        #if _newvar in self.variables and not isinstance(mstaVariable, _newvar):
        if _newvar in self.variables:
            return False
        self.variables.append(_newvar)
        return True

    def getVariableByName(self, _varname):
        variablesNames = [v.getName() for v in self.variables]
        assert _varname in variablesNames
        for vn in self.variables:
            if vn.getName() == _varname:
                return vn

    def getVariableByID(self, _varid):
        variablesID = [v.getID() for v in self.variables]
        assert _varid in variablesID
        for vid in self.variables:
            if vid.getID() == _varid:
                return vid

    def getVariableValueByName(self, _varname):
        assert _varname in self.variables
        return self.getVariableByName(_varname).getValue()

    def getVariableValueByID(self, _varid):
        return self.getVariableByID(_varid).getValue()


#############################################################################
## class mstaVariable: manage variable                                     ##
#############################################################################
class mstaVariable():
    mVR = it.count()
    def __init__(self):
        """Constructor."""
        self.ID = next(mstaVariable.mVR)
        self.name = ""
        self.alias = ""
        self.unit = self.setUnit("%") #Default value, i.e. percent
        self.value = 0.0
        self.dg = 0.0
        self.range = 0.0 # +/- range centred around value
        self.search = ELLIPSE(self.dg,  self.dg, 0.0) # By default circle search

    # Default operations
    # + addition
    def __add__(self, _other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        res.setRange(self.getRange()+self._other.getRange())
        res.setValue(self.getValue()+_other.getValue())
        return res
    def __iadd__(self, _other):
        self.range = self.getRange()+self._other.getRange()
        self.value = self.value+_other.getValue()
        return self
    # - substraction
    def __sub__(self, _other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        self.setRange(self.getRange()+self._other.getRange())
        res.setValue(self.getValue()-_other.getValue())
        return res
    def __isub__(self, _other):
        self.range = self.getRange()+self._other.getRange()
        self.value = self.value-_other.getValue()
        return self
    # * multiplication
    def __mul__(self, _other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        res.range = (_other.getValue() * self.getRange()) + (self.getValue() * _other.getRange())
        res.setValue(self.getValue() * _other.getValue())
        return res
    def __imul__(self, _other):
        self.range = (_other.getValue() * self.getRange()) + (self.getValue() * _other.getRange())
        self.setvalue = self.value * _other.getValue()
        return self
    # / division
    def __truediv__(self, _other):
        res = mstaVariable()
        if not _other.__class__ is mstaVariable:
            return NotImplemented
        if self.getUnit() != _other.getUnit():
            return NotImplemented
        else:
            res.setUnit(self.getUnit())
        if self.getName() != _other.getName():
            res.setName(f'{self.getName()}/{_other.getName()}')
        else:
            res.setName(self.getName())
        res = mstaVariable()
        res.range = (1/_other.getValue())*(self.getRange()+(self.getValue()/_other.getgetValue()*_other.getRange()))
        res.setValue(self.getValue() / _other.getValue())
        return res
    def __itruediv__(self, _other):
        self.range = (1/_other.getValue())*(self.getRange()+(self.getValue()/_other.getgetValue()*_other.getRange()))
        self.value = self.value / _other.getValue()
        return self
    # == equality
    def __eq__(self, _other):
        if isinstance(_other, str):  # Convenient to compare directly variables names
            return self.getName() == _other
        if self.isInRange(_other.getValue()) or _other.isInRange(self.getValue()):
            return True
        else:
            return False
    # != non equality
    def __ne__(self, _other):
        if not self.isInRange(_other.getValue()) and not _other.isInRange(self.getValue()):
            return True
        else:
            return False
    # < lower than
    def __lt__(self, _other):
        return self.getMax() < _other.getMin()
    def __le__(self, _other):
        return self.getMax() <= _other.getMin()
    # > upper thn
    def __gt__(self, _other):
        return self.getMin() > _other.getMax()
    def __ge__(self, _other):
        return self.getMin() >= _other.getMax()

    # Print the name only
    def __repr__(self):
        return self.name

    # Print itself
    def __str__(self):
        return(f'Name: {self.name}, alias: {self.alias}\n \
                unit: {self.unit}, range: +/-{self.getRange()}\n \
                {self.getSearch()}')

    # Test if the current variable as same Dg, direction and tolerance than variable _other
    # convenient during process
    def isEqual(self, _other):
        assert isinstance(_other, mstaVariable)
        retValue = (self.getDg() == _other.getDg()) and (self.getSearch() == _other.getSearch()) and (self.getUnit() == _other.getUnit())
        return retValue

    def getID(self):
        return self.ID

    def setName(self,_name):
        self.name = _name
    def getName(self):
        return self.name

    def setAlias(self,_alias):
        self.alias = _alias
    def getAlias(self):
        return self.alias

    def setUnit(self,_unit):
        assert _unit in cfg.UNIT.values()
        self.unit = _unit
    def getUnit(self):
        return self.unit

    def setValue(self,_value):
        self.value = _value
    def getValue(self):
        return self.value

    def getMin(self):
        return self.value - self.getRange()
    def getMax(self):
        return self.value + self.getRange()

    def setSearch(self, _M, _m, _d):
        self.search = ELLIPSE(_M, _m, _d)
    def getSearch(self):
        return self.search

    def setDg(self, _dg):
        assert isinstance(_dg, float)
        self.dg = _dg
    def getDg(self):
        return self.dg

    def setRange(self, _pm):
        assert isinstance(_pm, float)
        self.range = _pm
    def getRange(self):
        return self.range

    def isInRange(self, _value):
        return(_value >= self.getMin() and _value <= self.getMax())

    # Return False only for phi units and other (not affected)
    def isMetric(self):
        return not (self.getUnit() == cfg.UNIT['phi'] or self.getUnit() == cfg.UNIT['other'])

    ###############################################
    # Geographic functions
    ###############################################
    # Return features of the temporary layer which are neighboors of the variable
    def GetNeiborhoodPoints(self, temporaryLayer, centralPoint, pointsDB):
        assert isinstance(centralPoint, mstaPoint)
        assert isinstance(temporaryLayer, QgsVectorLayer)
        retValue = list()
        # Construct an ellipse geometry or circle when semiMajor = semiMinor
        ellipse = QgsEllipse(centralPoint, self.getSearch().getMajor(), self.getSearch().getMinor(),self.getSearch().getDirection())
        if ellipse.area() == 0.0:   # If ellipse have 0 area
            return retValue             # return an empty list
        # Select in the bounding box of the ellipse/circle geometry to restrict the list of points to look at
        request = QgsFeatureRequest()
        request.setFilterRect(ellipse.boundingBox()).setFlags(QgsFeatureRequest.ExactIntersect)
        # Loop over the select points inside the box if any
        for f in temporaryLayer.getFeatures(request):
            if QgsGeometry(ellipse.toPolygon()).contains(f.geometry()) and f.id() != centralPoint.getID():
                retValue.append(pointsDB[f.id()-1])  # Construction of the list of neighbor mstaPoints
        return retValue

#############################################################################
## class mstaTrendCase: manage trend case                                  ##
#############################################################################
class mstaTrendCase():
    mTC = it.count()
    def __init__(self, _variables = None, _comp = None):
        """Constructor."""
        self.ID = next(mstaTrendCase.mTC)
        # Normally one case should be defined for same variable but
        # it is eventually possible to manage 2 different variables
        if isinstance(_variables, list): # Two different variables
            assert len(_variables) == 2
            assert _comp in cfg.COMP.keys()
            assert isinstance(_variables[0], mstaVariable) and isinstance(_variables[1], mstaVariable)
            self.compSigne = cfg.COMP[_comp]
            self.leftVar = _variables[0]
            self.rightVar = _variables[1]
        elif _variables: # Same variable
            assert _comp in cfg.COMP.keys()
            assert isinstance(_variables, mstaVariable)
            self.compSigne = cfg.COMP[_comp]
            self.leftVar = _variables
            self.rightVar = _variables
        else: # Default init
            self.compSigne = cfg.COMP['none']
            self.leftVar = mstaVariable()
            self.rightVar = mstaVariable()

    # Print itself
    def __str__(self):
        if self.compSigne != '':
            return (f'{self.leftVar.getName()} {self.compSigne} {self.rightVar.getName()}')
        else:
            return ''

    # define equality or not between two mstaTrendCase objects
    def __eq__(self,_other):
        assert isinstance(_other, mstaTrendCase)
        if self.getLeftVar().getName() == _other.getLeftVar().getName() and \
           self.getRightVar().getName() == _other.getRightVar().getName() and \
           self.getComp() == _other.getComp():
            return True
        else:
            return False

    # Convenient to test if a case is of type GSTA. mstaTrendCase are never of type GSTA -> always False
    def isGSTATrend(self):
        return False

    def isComposed(self):
        return False

    # Use for specific printing in case of a GSTA trend
    def getGSTATrendText(self):
        assert isinstance(self.leftVar, mstaVariable)
        assert isinstance(self.rightVar, mstaVariable)
        assert self.leftVar.getAlias() == self.rightVar.getAlias()  # The variables have to be the same (m, sd or sk)
        retValue = ""
        if self.leftVar.getAlias() == "Mean":  # Mean
            if self.compSigne == cfg.COMP['sup']:
                if self.leftVar.isMetric():
                    retValue += 'F'
                else:
                    retValue += 'C'
            else:
                if self.leftVar.isMetric():
                    retValue += 'C'
                else:
                    retValue += 'F'
        elif self.leftVar.getAlias() == "Sorting":  # Sorting
            if self.compSigne == cfg.COMP['sup']:
                retValue += 'B'
            else:
                retValue += 'P'
        elif self.leftVar.getAlias() == "Skewness":  # Skewness
            if self.compSigne == cfg.COMP['sup']:
                if self.leftVar.isMetric():
                    retValue += '+'
                else:
                    retValue += '-'
            else:
                if self.leftVar.isMetric():
                    retValue += '-'
                else:
                    retValue += '+'
        return (retValue)

    def getID(self):
        return self.ID

    def setComp(self, _op):
        assert _op != ''
        self.compSigne = cfg.COMP[_op]

    def getComp(self):
        return(self.compSigne)

    def setLeftVar(self, _var):
        assert isinstance(_var, mstaVariable)
        self.leftVar = _var

    def getLeftVar(self):
        return self.leftVar

    def setRightVar(self, _var):
        assert isinstance(_var, mstaVariable)
        self.rightVar = _var

    def getRightVar(self):
        return self.rightVar

    def getVars(self):
        return [self.leftVar, self.rightVar]

    # Compare the two variables and return if they have same research parameters (Dg, angle) and same units
    def isValidTrend(self):
        return self.leftVar.isEqual(self.rightVar)

    # Get the result of the comparison between centralPoint value and neiborPoint value
    def compute(self, centralPoint, neighborPoint, surroundingDict):
        centralPointVariable = centralPoint.getVariableByName(self.getLeftVar().getName())
        neighborPointVariable = neighborPoint.getVariableByName(self.getRightVar().getName())
        # Check if neighborPoint is in surrounding list of variables points
        if not (neighborPoint in surroundingDict[centralPointVariable.getName()] and neighborPoint in surroundingDict[neighborPointVariable.getName()]):
            return False, ""
        if self.getComp() == cfg.COMP['sup']:
            if centralPointVariable > neighborPointVariable:
                return True, self.__str__()
            else:
                return False, ""
        elif self.getComp() == cfg.COMP['inf']:
            if centralPointVariable < neighborPointVariable:
                return True, self.__str__()
            else:
                return False, ""
        elif self.getComp() == cfg.COMP['eq']:
            if centralPointVariable == neighborPointVariable:
                return True, self.__str__()
            else:
                return False, ""
        else:  # Should normally never be the case
            return False, ""

#############################################################################
## class mstaComposedTrendCase: manage trend case                          ##
#############################################################################
class mstaComposedTrendCase():
    mCTC = it.count()
    # By default _trendCase is null, but most of the time a mstaComposedTrendCase is
    # initialized with a simple trend case or a list of trend case (GSTA). In this latter case _op must be given also.
    def __init__(self, _trendCase = None, _op = None):
        self.ID = next(mstaComposedTrendCase.mCTC)
        """Constructor for trend case"""
        self.composedGSTATrend = False # by default it is false, can be change through dedicated function
        if isinstance(_trendCase, list): # list of trend cases, minimum 2 trends
            assert isinstance(_op, list) or isinstance(_op, mstaOperand) # At least one operand object must be defined
            if isinstance(_op, list):
                self.operandList = _op  # A list of operand is given
            else:
                self.operandList = [_op] # One object is given, the list is created with this object as first element
            self.trendsList = _trendCase
        elif isinstance(_trendCase, mstaTrendCase) or isinstance(_trendCase, mstaComposedTrendCase): # one trend object
            if _op:
                print("** Attention un operand incomplet **")
                self.operandList = [_op] # Should not append as an operand object point on two trend cases
            else:
                self.operandList = list()
            self.trendsList = [_trendCase]
        else:
            self.trendsList = list()
            self.operandList = list()

    # Function to check if all the trend IDs present in the operand list are present in the trend case list
    def check(self):
        if len(self.trendsList) == 0:
            return True, ""
        errorStr = ""
        IDList = self.getTrendIDList()
        for op in self.operandList:
            if not op.getLeftTrendID() in IDList or not op.getRightTrendID() in IDList:
                errorStr += "{} or {} not in list\n".format(self.getTrendByID(op.getLeftTrendID()).__str__(),self.getTrendByID(op.getRightTrendID()).__str__())
        return errorStr == "", errorStr

    def __getitem__(self, item):
        assert item < len(self.trendsList)
        return self.trendsList[item]

    def __str__(self): # Complex print which take care of GSTA like trend cases
        retValue = ""
        if len(self.trendsList) == 0:
            return retValue
        if len(self.operandList) == 0:
            retValue = self.trendsList[0].__str__()
        else:
            retValue += "({}".format(self.operandList[0].getLeftTrend(self.trendsList).__str__())
            for op in self.operandList:
                retValue += " {} {}".format(op.__str__(), op.getRightTrend(self.trendsList).__str__())
            retValue += ")"
        return retValue

    # For convenience and to be homogeneous with mstaTrendCase class
    def getGSTATrendText(self):
        assert isinstance(self, mstaComposedTrendCase)
        retValue = ""
        for c in self.getTrend():
            assert isinstance(c, mstaTrendCase)
            retValue += c.getGSTATrendText()
        retValue += "\n"
        return retValue

    def setComposedGSTATrend(self, _bool):
        self.composedGSTATrend = _bool

    def isGSTATrend(self):
        return self.composedGSTATrend

    def isComposed(self):
        return True

    def getID(self):
        return self.ID

    # Equality between two mstaComposedTrendCase objects
    def __eq__(self, _other):
        assert isinstance(_other, mstaComposedTrendCase)
        if self.getTrendCount() != _other.getTrendCount(): # if not same length of trend list -> equal = False
            return False
        # from here both list have same length
        # now compare the trend
        nCommonTrends = sum(1 for i in self.getTrend() if i in _other.getTrend())
        if self.getTrendCount() == nCommonTrends:  # Same elements
            return True
        else:
            return False

    # return the higher ID of mstaTrendCase object in the list
    def getMaxID(self):
        if len(self.trendsList) > 0:
            return max(t.getID for t in self.trendsList)
        else:
            return 0

    def getFlatTrendIDList(self):
        retValue = list()
        if len(self.trendsList) > 0:
            for tc in self.trendsList:
                if isinstance(tc, mstaComposedTrendCase):
                    retValue += tc.getTrendIDList()
                else:
                    retValue.append(tc.getID())
        return retValue

    def getTrendIDList(self):
        retValue = list()
        if len(self.trendsList) > 0:
            for tc in self.trendsList:
                    retValue.append(tc.getID())
        return retValue

    # Add an operand to the list
    def addOperand(self, _op):
        assert isinstance(_op, mstaOperand)
        self.operandList.append(_op)

    def getOperand(self, *args):
        if len(args) > 0:
            _id = args[0]
            assert _id < len(self.operandList)
            return self.operandList[_id]
        else:
            return self.operandList

    def getOperandCount(self):
        return len(self.operandList)

    def getTrend(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.trendsList)
            return self.trendsList[_id]
        else:
            return self.trendsList

    def getTrendByID(self, _id):
        for tc in self.trendsList:
            if tc.getID() == _id:
                return tc
        return None

    def getFirstTrend(self):
        assert len(self.trendsList) >= 1
        return self.trendsList[0]

    def getLastTrend(self):
        assert len(self.trendsList) >= 1
        return self.trendsList[-1]

    def getTrendCount(self):
        return len(self.trendsList)

    def addTrendCase(self, _trendcase, _operand = None):
        assert isinstance(_trendcase, mstaTrendCase) or isinstance(_trendcase, mstaComposedTrendCase)
        #if _operand != cfg.OPERAND['none'] and not _operand: # If no operand just store the trend case
        #    self.operandList.append(_operand)
        self.trendsList.append(_trendcase)

    def deleteTrendCase(self, _trendcase):
        assert _trendcase in self.trendsList
        for t in self.trendsList:
            if t == _trendcase:
                for op in self.operandList:
                    if t.getID() in op.getTrendIDS(): # The trend to delete is used in an operand
                        if t.getID() == op.getLeftTrendID():
                            print("ce qui ne devait pas arriver ...est arrivé")
                            op.eraseLeftTrendID() # Should normally not append
                        else:
                            print("efface un ID d'un trend case à droite")
                            op.eraseRightTrendID() # Should be the case all the time
                self.trendsList.remove(t)

    def deleteOperand(self, _op):
        assert _op in self.operandList
        for op in self.operandList:
            if op == _op:
                self.operandList.remove(op)

    # Return a flatten list of the variables present in the various defined trends
    def getVars(self):
        retValue = list()
        for t in self.trendsList:
            if isinstance(t, mstaComposedTrendCase):
                for tt in t.getTrend():
                    retValue += tt.getVars()
            else:
                retValue += t.getVars()
        return retValue

    # Compare the two variables and return if they have same research parameters (Dg, angle) and same units
    def isValidTrend(self):
        retValue = True
        for t in self.trendsList:
            retValue = t.isValidTrend()
        return retValue

    # Get the result of the comparison between centralPoint value and neighborPoint value
    # This function is eventualy recursive in case of multiple mstacomposedtrendcase objects
    def compute(self, centralPoint, neighborPoint, surroudingDict):
        testValue, textValue = self.getFirstTrend().compute(centralPoint, neighborPoint,surroudingDict)
        for op in self.operandList:
            opSettings = op.getOperandSettings()
            test, text = self.getTrendByID(opSettings[2]).compute(centralPoint, neighborPoint, surroudingDict)
            if opSettings[0] == cfg.OPERAND['et']:
                testValue &= test
            elif opSettings[0] == cfg.OPERAND['ou']:
                testValue |= test
            elif opSettings[0] == cfg.OPERAND['xou']:
                testValue ^= test
            if testValue:
                textValue += "{} {}".format(opSettings[0], text)
        return testValue, textValue

#############################################################################
## class mstaOperand: manage trend case                                    ##
#############################################################################
class mstaOperand():
    mOP = it.count()
    def __init__(self, _op = cfg.OPERAND['none'], _idLeft = None, _idRight = None, _level = None):
        self.ID = next(mstaOperand.mOP)
        if _op != cfg.OPERAND['none']:  # if an operand is given there must be two trend cases given
            assert _idLeft != None
            assert _idRight != None
            assert _level != None
            self.idTrendLeft = _idLeft       # ID of the left case
            self.idTrendRight = _idRight     # ID of the right case
            self.level = _level     # Level of the trend case
            self.op = _op           # operand between the two cases
        else:
            self.idTrendLeft = None     # ID of the left case
            self.idTrendRight = None    # ID of the right case
            self.level = None     # Level of the trend case
            self.op =  cfg.OPERAND['none']

    def __str__(self):
        return self.op

    # Set full OPERAND information
    def setOperand(self, _op, _idLeft, _idRight, _level = None):
        assert _op != cfg.OPERAND['none'] and _op in cfg.OPERAND.values()
        assert _idLeft != None
        assert _idRight != None
        assert _level != None
        self.idTrendLeft = _idLeft
        self.idTrendRight = _idRight
        self.level = _level
        self.op = _op

    # just set the operand variable
    def setOP(self, _op):
        assert _op != cfg.OPERAND['none'] and _op in cfg.OPERAND.values()
        self.op = _op

    def getOP(self):
        return self.op

    def getLeftTrendID(self):
        return self.idTrendLeft

    def getLeftTrend(self, _trendList):
        for tc in _trendList:
            if tc.getID() == self.idTrendLeft:
                return tc
        return None

    def setLeftTrendID(self, _id):
        assert _id != None
        self.idTrendLeft = _id

    def eraseLeftTrendID(self):
        self.idTrendLeft = None

    def getRightTrendID(self):
        return self.idTrendRight

    def getRightTrend(self, _trendList):
        for tc in _trendList:
            if tc.getID() == self.idTrendRight:
                return tc
        return None

    def setRightTrendID(self, _id):
        assert _id != None
        self.idTrendRight = _id

    def eraseRightTrendID(self):
        self.idTrendRight = None

    # Return IDs of trend cases left and right
    def getTrendIDS(self):
        return [self.idTrendLeft, self.idTrendRight]

    def getLevel(self):
        return (self.level)

    def setLevel(self, _level):
        self.level = _level

    # return a list with operand first, the two cases IDs and the level
    def getOperandSettings(self):
        return [self.op, self.idTrendLeft, self.idTrendRight, self.level]

    # Return current ID of the operand
    def getID(self):
        return self.ID

#############################################################################
# Class to store and manage results of MSTA computation
#############################################################################
class mstaResults():
    def __init__(self, _pointID=None):
        if _pointID:
            self.pointID = _pointID
        else:
            self.pointID = 0
        self.usedNeighborPointCount = 0
        self.easting = list()
        self.northing = list()
        self.distance = list()
        self.trend = ""

    def __repr__(self):
        str = "\nPoint ID: {}\nNeighbor: {} (used)\nEasting: {}\nNorthing: {}\n" \
              "Distance: {}".format(self.pointID,
                                    self.usedNeighborPointCount,
                                    self.easting,
                                    self.northing,
                                    self.distance)
        return str

    def __add__(self, other):
        for e in other.easting:
            self.SetEasting(e)
        for n in other.northing:
            self.SetNorthing(n)
        for d in other.distance:
            self.SetDistance(d)

    def SetEasting(self, _value):
        assert isinstance(_value, float)
        self.easting.append(_value)

    def GetEasting(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.easting)
            return self.easting[_id]
        else:
            return sum(self.easting)

    def SetNorthing(self, _value):
        assert isinstance(_value, float)
        self.northing.append(_value)

    def GetNorthing(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.northing)
            return self.northing[_id]
        else:
            return sum(self.northing)

    def GetDistance(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.distance)
            return self.distance[_id]
        else:
            return sum(self.distance)

    def GetNormalizedDistance(self):
        assert isinstance(self.distance, list)
        if len(self.distance) > 0:
            return sum(self.normalize(self.distance)) / len(self.distance)
        else:
            return 0.0

    def SetDistance(self, _value):
        assert isinstance(_value, float)
        self.distance.append(_value)

    def SetUsedNeighbor(self, _nbc):
        assert isinstance(_nbc, int)
        self.usedNeighborPointCount = _nbc

    def GetUsedNeighbor(self):
        return self.usedNeighborPointCount

    def normalize(self, _dataset):
        if isinstance(_dataset, list):
            normlist = list()
            min_value = min(_dataset)
            max_value = max(_dataset)
            for value in _dataset:
                tmp = (value - min_value) / (max_value - min_value)
                normlist.append(tmp)
        return normlist

    def SetTrendText(self, _str):
        self.trend = _str

    def GetTrendText(self):
        return self.trend