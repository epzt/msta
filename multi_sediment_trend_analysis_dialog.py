# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mstaDialog
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np

from PyQt5 import uic, QtWidgets, QtGui, QtCore
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from qgis import core, gui, utils
from qgis.core import *
from qgis.gui import *
from qgis.utils import *

from datetime import datetime

from .pyMstaTextFileAnalysisDialog import pyMstaTextFileAnalysisDialog
from .mstaCoreClass import mstaPoint as mp
from .mstaCoreClass import mstaVariable as mv
from .mstaCoreClass import mstaTrendCase as trend
from .mstaCoreClass import mstaComposedTrendCase as cpdtrend
from .mstaUtilsClass import *

CONTEXTINFO = {1:"Variable(s) information",
               2:"Trend(s) information",
               3:"GSTA variable information",
               4:"GSTA trend(s) information",
               5:"Current selected variable",
               6:"Points information",
               7:"__DEBUG__",
               999:""}

# constante definitions
UPDATEDB = {'varalias' : 0,
            'varrange' : 1,
            'varvalue' : 2,
            'vartrend' : 3,
            'varsearch' : 4}

# Change apply 19/11/2019 to work around a problem with resources not manage by uic
#Ui_MainWindow, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'ui_multi_sediment_trend_analysis_dialog_base.ui'))
# Old way to load the dialog
from .ui_multi_sediment_trend_analysis_dialog_base  import Ui_MainWindow

class mstaDialog(QMainWindow, Ui_MainWindow):
    def __init__(self, _iface, parent=None):
        """Constructor."""
        super(mstaDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)             
        
        # Actions management
        self.actionAppQuit.triggered.connect(self.close)
        self.actionFileImport.triggered.connect(self.DataFileImport)
        self.actionAbout.triggered.connect(self.DisplayAboutMSTA)
        self.actionSetWorkingDirectory.triggered.connect(self.SetWorkingDirectory)
        self.actionVariableListAll.triggered.connect(self.PrintAllVariablesList)
        self.actionVariableListSelected.triggered.connect(self.PrintSelectedVariablesList)
        #self.actionSelectOneVariable.triggered.connect(self.SelectOneVariable)
        #self.actionSelectAllVariables.triggered.connect(self.SelectAllVariables)
        self.actionGSTALikeVariable.triggered.connect(self.SetGSTAVariables)
        self.actionGSTALikeTrend.triggered.connect(self.SetGSTATrendCases)
        self.actionClearViewText.triggered.connect(self.SetClearText)
        self.actionTrendList.triggered.connect(self.PrintTrendsList)
        self.actionTrendSet.triggered.connect(self.SetMSTATrendCases)
        self.actionModifyVariables.triggered.connect(self.ModifyVariables)
        self.actionDeleteVariables.triggered.connect(self.DeleteOneVariable)
        #  self.actionResetInitial.triggered.connect(self.resetInitialVariables)
        self.actionDeleteAllTrends.triggered.connect(self.DeleteAllTrends)
        self.actionComputeMSTA.triggered.connect(self.ComputeMSTA)
        self.actionVariableSettings.triggered.connect(self.PrintVariableHelp)
        self.actionTrendSettings.triggered.connect(self.PrintTrendHelp)
        self.actionSelectVariables.triggered.connect(self.SelectVariables)
        self.actionClearSelect.triggered.connect(self.ClearSelectedVariables)

        self.setGeometry(10, 10, 400, 400)
        self.setWindowTitle('Multi Sediment Trend Analysis')

        self.menuVariables.setEnabled(False)
        self.menuTrends.setEnabled(False)
        self.actionGSTALikeTrend.setEnabled(False)
        self.computeMSTA.setEnabled(False)
        self.actionClearSelect.setEnabled(False)
        self.actionVariableListSelected.setEnabled(False)

        # Variables
        self.iface = _iface
        self.workingDir = os.path.expanduser("~")
        self.points = []
        # A list of all the variables names in the current dataset
        self.totalVariablesName = []
        # The list of the current selected variable names, i.e. the working variables
        self.selectedVariableNames = []
        # A list of all the variables objects of class mstaVariable
        self.variablesObjectsList = []
        # The current trend case(s) object
        self.trendCases = mstaComposedTrendCase()
        # "Central Widget" expands to fill all available space
        self.textwidget = QTextEdit()
        self.setCentralWidget(self.textwidget)
        self.textwidget.setEnabled(True)
        self.textwidget.setTextColor(QColor("black"))
        fontWeight = self.textwidget.currentFont().weight()
        self.textwidget.setTabStopWidth(fontWeight)
        self.temporaryLayer = None

    ###############################################
    def DisplayAboutMSTA(self):
        #about=Ui_AboutDlg()
        #about.exec()
        QMessageBox.information(self, "Information", "MSTA plugin")

    ###############################################
    def PrintVariableHelp(self):
        self.textwidget.setHtml("<p><strong>Variable\'s settings</strong> </p>\
        <p>Variables are loaded with the data set. By default, just the name found in the data set is used to access a variable.</p> \
        <p>In the menu \"Variables\", you can modify the variables setting after selected a variable name.<br> \
        <em>(\"Variables\" item is enabled only if a data set is loaded with it\'s corresponding variables)</em></p>")

    def PrintTrendHelp(self):
        return

    ###############################################
    def SetWorkingDirectory(self):
        self.workingDir = QFileDialog.getExistingDirectory(self, self.workingDir, "Select working directory...", QFileDialog.ShowDirsOnly)

    ###############################################
    def DataFileImport(self):
        # Choice of the file name
        fullPathFileName,_= QFileDialog.getOpenFileName(self,"Open a data file", 
                                                self.workingDir,"Text file(s) (*.txt *.csv)")

        if os.path.isfile(fullPathFileName): 
            importDlg = pyMstaTextFileAnalysisDialog(fullPathFileName)
            if importDlg.exec_() == QDialog.Rejected:
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            if not importDlg.getVariableNameList():
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            try:
                # get the lists of information
                coordsids,coordsnames,varids,varnames=importDlg.getVariableNameList()
                # get the data (variables values)
                dataset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(varnames),
                                usecols=tuple(varids)
                                )
                # get the coordinates
                coordsset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(coordsnames),
                                usecols=tuple(coordsids)
                                )
                # QMessageBox.information(self, "Import data...", f'{dataset.shape[0]} rows have been imported.')
            except ValueError:
                QMessageBox.critical(self, "Load data file error", "An error occured while reading data file.\nNo data imported")
                return

        # Create a temporary layer and add it to the current project
        # Create the database use for computations
        try:
            self.temporaryLayer = self.CreateTemporaryLayer(dataset, varnames, coordsset, coordsnames, QFileInfo(fullPathFileName).baseName())
        except:
            QMessageBox.critical(self, "Temporary layer error", "An error occured while creating temporary layer.")
            return
        try:
            self.createPointDB(dataset, varnames, coordsset, coordsnames)
        except:
            QMessageBox.critical(self, "Database initialisation error", "An error occured during database creation")
            return

        # Save information before living, just de names, variables are not created yet
        self.totalVariablesName = varnames.copy()
        self.updateLogViewPort(6, f'{len(self.points)} points created')
        self.updateLogViewPort(1, self.totalVariablesName)
        # All variables are selected by default at the beginning
        self.selectedVariableNames = self.totalVariablesName.copy()
        # Data set is loaded, variables and trends can be manage
        self.menuVariables.setEnabled(True)
        self.menuTrends.setEnabled(True)
        return

    ###############################################
    # _dataset: np.array of n samples lines and m variables columns
    # _varnames: list of the variables names
    # _coordsnames: list of the two coordinates variables
    # _coordsset: np.array of n samples lines and two coordinates
    # _filename: name of the text file (without extension) which contains the original data
    def CreateTemporaryLayer(self, _dataset, _varnames, _coordsset, _coordsnames, _filename):
        # Selection of a reference system eventually different from the current project
        theProj = QgsProjectionSelectionDialog(self)
        theProj.setCrs(QgsProject.instance().crs())
        result = theProj.exec_()
        if result == QDialog.Rejected:
            QMessageBox.information(self, "Reference system", "Layer reference system is the same to the current project")
            URI=f'point?crs={QgsProject.instance().crs().authid()}'
        else:
            URI=f'point?crs={theProj.crs().authid()}'
        # create the temporary layer
        vl = QgsVectorLayer(URI, f'msta_{_filename}_Layer', "memory")
        pr = vl.dataProvider()
        
        # create fields
        # TODO: define the list of fields to create to store the results
        pr.addAttributes([QgsField("Trend", QVariant.String)])
        pr.addAttributes([QgsField("Length", QVariant.Double)])
        pr.addAttributes([QgsField("Module", QVariant.Double)])
        pr.addAttributes([QgsField("Comments", QVariant.String)])
        vl.updateFields() # tell the vector layer to fetch changes from the provider

        # add features
        for i in range(_dataset.shape[0]):
            fet = QgsFeature(i)  #  Set the ID in the same time so as to correspond with ID of the database
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(_coordsset[_coordsnames[0]][i],_coordsset[_coordsnames[1]][i])))
            pr.addFeatures([fet])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl.updateExtents()
        # Add the temporary layer to the current project
        QgsProject.instance().addMapLayer(vl)
        return vl

    ###############################################
    # _points: np.array of n samples lines and two coordinates
    # _variables: np.array of n samples lines and m variables columns
    # _coordnames: list of the two coordinates variables
    # _varnames: list of the variables names
    # The variable names and values are stored at each point location
    def createPointDB(self, _variables, _varnames, _points, _coordnames):
        # first loop over the points
        for i in range(_points.shape[0]):
            # mp is mstaPoint
            newpt = mp(_points[_coordnames[0]][i], _points[_coordnames[1]][i])
            newpt.setID(i+1)
            for j in range(len(_varnames)):
                # mv is mstaVariable
                newvar = mv()
                newvar.setName(_varnames[j])
                newvar.setAlias(_varnames[j]) # Alias = name by default
                newvar.setUnit("%") # By default % unit
                newvar.setValue(_variables[i][j])
                newvar.setDg(0.0) # By default Dg is null
                newvar.setRange(0.0) # By default, no range
                newvar.setSearch(0.0,0.0) # By default omnidirectional
                newpt.addVariable(newvar)
            self.points.append(newpt)
        # As each point has the same variable list, the object list is equal to the list of the 1st point by default
        self.variablesObjectsList = self.points[0].getVariables().copy()

    ###############################################
    # Function to update the variables in the points database
    # _newValue : list of changes to apply in relation with _code
    # this function make the change(s) only on current selected variables.
    def updatePointsDB(self, _newValue):
        progress = QProgressDialog("Update points...", "Cancel", 0, len(self.points), self)
        progress.setWindowFlags(QtCore.Qt.Dialog | QtCore.Qt.FramelessWindowHint | QtCore.Qt.CustomizeWindowHint)
        progress.setModal(True)
        progress.setMinimumDuration(0)
        progress.setCancelButton(None)  # Remove the cancel button.
        # Changes are operate on all the points
        i = 0
        for p in self.points:
            i = i + 1
            progress.setValue(i)
            for newv in _newValue:
                p.updateVariable(newv)
        progress.close()
        return

    ###############################################
    # Add _text information on the viewport of the application
    # base on _context (see CONTEXTINFO dict definition)
    def updateLogViewPort(self, _context, _text):
        dt = datetime.now()
        self.textwidget.append(f'\n{dt.strftime("%d %b %Y, %H:%M:%S")}: {CONTEXTINFO[_context]}')
        if not _text:
            self.textwidget.append("\t------")
        if isinstance(_text, list):
            for i in _text:
                self.textwidget.append(f'{i.__str__()}')
        else:
            self.textwidget.append(f'{_text.__str__()}')

    ###############################################
    def SetClearText(self):
        self.textwidget.clear()

    ###############################################
    # Print the current defined variable(s)
    def PrintAllVariablesList(self):
        if not self.totalVariablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        # Print all the current loaded variables
        self.updateLogViewPort(1, self.variablesObjectsList)

    ###############################################
    # Print the current selected variable(s)
    def PrintSelectedVariablesList(self):
        if not self.selectedVariableNames:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        # Print the current selected variables
        self.updateLogViewPort(1, [v for v in self.variablesObjectsList if v.getName() in self.selectedVariableNames])

    ###############################################
    # Print the defined trend(s)
    def PrintTrendsList(self):
        if self.trendCases.getTrendCount() == 0:
            QMessageBox.information(self, "Trend case", "No trend case(s) defined yet.")
            return
        self.updateLogViewPort(2, self.trendCases.__str__())

    ###############################################
    # Definition of the GSTA variables to use for mean, sorting and skewness
    def SetGSTAVariables(self):
        # Use to fill the variable combobox of the dialog
        tmpVarObjectsList = self.variablesObjectsList.copy()
        self.selectedVariableNames.clear()
        # Open dialog of variables settings for MEAN variable
        dlg = setMSTAVariableOptionDlg(tmpVarObjectsList)
        dlg.setVariableAlias("Mean")
        while True:
            result = dlg.exec()
            if result == QDialog.Accepted:
                newVar = dlg.getVariableDefinition()
                for i,v in enumerate(tmpVarObjectsList):
                    if v.getName() == newVar.getName():
                        del tmpVarObjectsList[i]
                        self.selectedVariableNames.append(newVar.getName())
                for i,v in enumerate(self.variablesObjectsList):
                    if v.getName() == newVar.getName():
                        self.variablesObjectsList[i] = newVar
                break
            elif result == QDialog.Rejected:
                if QMessageBox.question(self, "Mean variable", "No mean variable selected", \
                                        QMessageBox.Abort|QMessageBox.Retry) == QMessageBox.Abort:
                    return

        # Open dialog of variables settings for SORTING variable
        dlg = setMSTAVariableOptionDlg(tmpVarObjectsList)
        dlg.setVariableAlias("Sorting")
        while True:
            result = dlg.exec()
            if result:
                newVar = dlg.getVariableDefinition()
                for i,v in enumerate(tmpVarObjectsList):
                    if v.getName() == newVar.getName():
                        del tmpVarObjectsList[i]
                        self.selectedVariableNames.append(newVar.getName())
                for i, v in enumerate(self.variablesObjectsList):
                    if v.getName() == newVar.getName():
                        self.variablesObjectsList[i] = newVar
                break
            elif result == QDialog.Rejected:
                if QMessageBox.question(self, "Sorting variable", "No sorting variable selected", \
                                    QMessageBox.Abort | QMessageBox.Retry) == QMessageBox.Abort:
                    return

        # Open dialog of variables settings for SKEWNESS variable
        dlg = setMSTAVariableOptionDlg(tmpVarObjectsList)
        dlg.setVariableAlias("Skewness")
        while True:
            result = dlg.exec()
            if result:
                newVar = dlg.getVariableDefinition()
                for i,v in enumerate(tmpVarObjectsList):
                    if v.getName() == newVar.getName():
                        del tmpVarObjectsList[i]
                        self.selectedVariableNames.append(newVar.getName())
                for i, v in enumerate(self.variablesObjectsList):
                    if v.getName() == newVar.getName():
                        self.variablesObjectsList[i] = newVar
                break
            elif result == QDialog.Rejected:
                if QMessageBox.question(self, "Skewness variable", "No skewness variable selected", \
                                    QMessageBox.Abort | QMessageBox.Retry) == QMessageBox.Abort:
                    return

        if len(self.selectedVariableNames) == 3: # Three variables must be selected
            self.updatePointsDB(self.variablesObjectsList)  # Update the corresponding variables at each points
            self.updateLogViewPort(5, self.selectedVariableNames)
            # Update menu entries
            self.actionClearSelect.setEnabled(True)
            self.actionVariableListSelected.setEnabled(True)
            # GSTA variables are defined, trends can be manage
            self.actionGSTALikeTrend.setEnabled(True)
        else:
            QMessageBox.information(self, "GSTA variable definition", "3 variables must defined for a GSTA analysis\nOnly {} actually defined".format(len(self.selectedVariableNames)))
            self.actionClearSelect.setEnabled(False)
            self.actionVariableListSelected.setEnabled(False)
            # GSTA variables are defined, trends can be manage
            self.actionGSTALikeTrend.setEnabled(False)

    ###############################################
    def ModifyVariables(self):
        # Open dialog of variables settings
        dlg = setMSTAVariableOptionDlg(self.variablesObjectsList)
        ok = dlg.exec()
        if ok:
            # Update the list of the mstaVariable
            newVar = dlg.getVariableDefinition()
            for i,v in enumerate(self.variablesObjectsList):
                if v.getName() == newVar.getName():
                    self.variablesObjectsList[i] = newVar
            self.variablesObjectsList = sorted(self.variablesObjectsList, key=lambda mstaVariable: mstaVariable.name)
            self.updatePointsDB(self.variablesObjectsList)  # Update the corresponding variables at each points
            self.updateLogViewPort(1, "Variable {} has been modified.".format(newVar.getName()))
            # If GSTA varaiables have been set before, delete one variable do not allow GSTA analysis
            if self.actionGSTALikeTrend.isEnabled():
                self.actionGSTALikeTrend.setEnabled(False)
            return
        return

    ###############################################
    def DeleteOneVariable(self):
        # Get the name of the variable to delete from user
        variable, ok = QInputDialog.getItem(self, 'Delete a variable', 'Select a variable', self.selectedVariableNames, 0,
                                            False)
        if ok:
            for vol in self.variablesObjectsList:
                if vol.getName() == variable:
                    if QMessageBox.question(self, "Variable", "Are you sure you want to delete variable {} ?".format(variable)) == QMessageBox.Yes:
                        # Delete the variable name only from selected variable name list, variableObjectsList is not modified
                        del self.selectedVariableNames[self.selectedVariableNames.index(variable)]
                        self.updateLogViewPort(1, "Variable {} has been delete.".format(variable))
                    break

    '''
    ###############################################
    def resetInitialVariables(self):
        if QMessageBox.question(self, "Variable",
                                "Are you sure you want to reinitilized to initial variable set ?") == QMessageBox.Yes:
            # Retreive initial variable name list
            self.selectedVariableNames.clear()
            assert len(self.totalVariablesName) > 0
            self.selectedVariableNames = self.totalVariablesName.copy()
            # Reinitialized the list of variable objects to variables contained in initial dataset
            self.variablesObjectsList.clear()
            self.variablesObjectsList = self.points[0].getVariables().copy()
            self.updatePointsDB(self.variablesObjectsList)  # Update the corresponding variables at each points
            # In case GSTA variables were previously defined, it is reset
            self.GSTAVariables = {'mean': '', 'sorting': '', 'skewness': ''}
            # Print information
            self.updateLogViewPort(1, "Variables list has been set to initial to default current dataset.")
            self.updateLogViewPort(1, self.variablesObjectsList)
    '''
    ###############################################
    # Definition of the trend case(s) for a GSTA analysis
    def SetGSTATrendCases(self):
        dlg = setGSTATrendCasesDlg(self.variablesObjectsList, self.trendCases)
        result = dlg.exec()
        if result:
            if dlg.getTrendCases().getTrendCount() > 0:
                self.trendCases = dlg.getTrendCases()
            else:
                self.trendCases = mstaComposedTrendCase()
                self.computeMSTA.setEnabled(False)

    ###############################################
    def SetMSTATrendCases(self):
        dlg = setMSTATrendCasesDlg(self.variablesObjectsList, self.trendCases) # Variable definition is the same for all points
        result = dlg.exec()
        if result:
            self.trendCases = dlg.getTrendCases()
            self.computeMSTA.setEnabled(True)
            return

    ###############################################
    def DeleteAllTrends(self):
        if self.trendCases.getTrendCount() == 0:
            QMessageBox.information(self, "Trend case(s)", "No trend case(s) defined yet.")
            return
        if QMessageBox.question(self, "Trend cases(s)", "Are you sure you want to delete all defined trends ?") == QMessageBox.Yes:
            self.trendCases = mstaComposedTrendCase()
            self.computeMSTA.setEnabled(False)
        return

    ###############################################
    def ComputeMSTA(self):
        assert self.trendCases.getTrendCount() > 0 # Must have at least one trand to study
        assert len(self.variablesObjectsList) > 0 # Must have at least one variable in the current selected list
        assert self.temporaryLayer # Check the temporary layer is set

        for point in self.points:
            for trend in self.trendCases:
                if isinstance(trend, mstaTrendCase):
                    QMessageBox.information(self, "*/*\*/*\*", "{}".format(trend.__repr__()))
                if isinstance(trend, mstaComposedTrendCase):
                    QMessageBox.information(self, "*/*\*/*\*", "{}".format(trend.__repr__()))
                if trend.getLeftVar().getSearch().isCircular(trend.getLeftVar().getDg()):
                    QMessageBox.information(self, "*/*\*/*\*", "Circ: {}".format(trend.getLeftVar().getDg()))
                else:
                    minor=trend.getRightVar().getSearch().getTolerance()
                    major=trend.getLeftVar().getDg()
                    QMessageBox.information(self, "*/*\*/*\*", "(Ellispe: {}-{})".format(major,minor))
            # TODO:
            # 1 - construction the ellipse/circle
            # 2 - select all points inside the ellipse/circle
            # 3 - deselect the current central point (working point)

                # pointIdList = self.GetNeiborhoodPointsID(point, )
        return

    ###############################################
    def GetNeiborhoodPointsID(self, centralPoint, semiMajor, semiMinor, azimuth):
        # Construct an ellipse geometry or circle when semiMajor = semiMinor
        ellipseGeom = QgsEllipse(centralPoint, semiMajor, semiMinor, azimuth)
        # Select points within the boundingbox rectangle of the ellipse/circle
        # just to restrict the number of points onto which loop over
        self.temporaryLayer.selectByRect(ellipseGeom.boundingBox())
        for f in self.temporaryLayer.selectedFeatures():
            if not f.geometry().within(QgsGeometry(ellipseGeom.toPolygon())):
                self.temporaryLayer.deselect(f.id())
        return self.temporaryLayer.selectedFeatureIds()

    ###############################################
    def SelectVariables(self):
        selVar = setSelectedVariablesDlg(self.variablesObjectsList, self.selectedVariableNames)
        selVar.exec_()
        if len(selVar.getSelectedVariables()) > 0:
            self.actionClearSelect.setEnabled(True)
            self.actionVariableListSelected.setEnabled(True)
            self.selectedVariableNames = selVar.getSelectedVariables().copy()

    ###############################################
    def ClearSelectedVariables(self):
        if QMessageBox.question(self, "MSTA Variables management", "Do you really want to clear current selected variables ?") == QMessageBox.No:
            return
        self.selectedVariableNames.clear()  # Clear list of selected variables
        self.actionClearSelect.setEnabled(False)
        self.actionVariableListSelected.setEnabled(False)
        for v in self.variablesObjectsList:
            self.selectedVariableNames.append(v.getName())  # construct new list with all variables names