# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mstaDialog
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np

from PyQt5 import uic
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

from datetime import datetime

from .pyMstaTextFileAnalysisDialog import pyMstaTextFileAnalysisDialog
from .mstaCoreClass import mstaPoint as mp
from .mstaCoreClass import mstaVariable as mv
from .mstaCoreClass import mstaTrendCase as trend
from .mstaCoreClass import mstaComposedTrendCase as cpdtrend
from .mstaUtilsClass import *


CONTEXTINFO = {1:"Variable(s) information",
               2:"Trend(s) information",
               3:"GSTA variable information",
               4:"GSTA trend(s) information",
               5:"Current selected variable",
               6:"Points information",
               7:"__DEBUG__",
               999:""}

# constante definitions
UPDATEDB = {'varalias' : 0,
            'varrange' : 1,
            'varvalue' : 2,
            'vartrend' : 3,
            'varsearch' : 4}

Ui_MainWindow, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui_multi_sediment_trend_analysis_dialog_base.ui'))


class mstaDialog(QMainWindow, Ui_MainWindow):
    def __init__(self, _iface, parent=None):
        """Constructor."""
        super(mstaDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)             
        
        # Actions management
        self.actionAppQuit.triggered.connect(self.close)
        self.actionFileImport.triggered.connect(self.DataFileImport)
        self.actionAbout.triggered.connect(self.DisplayAboutMSTA)
        self.actionSetWorkingDirectory.triggered.connect(self.SetWorkingDirectory)
        self.actionVariableListAll.triggered.connect(self.PrintAllVariablesList)
        self.actionVariableListSelected.triggered.connect(self.PrintSelectedVariablesList)
        #self.actionSelectOneVariable.triggered.connect(self.SelectOneVariable)
        #self.actionSelectAllVariables.triggered.connect(self.SelectAllVariables)
        self.actionGSTALikeVariable.triggered.connect(self.SetGSTAVariables)
        self.actionGSTALikeTrend.triggered.connect(self.SetGSTATrendCases)
        self.actionClearViewText.triggered.connect(self.SetClearText)
        self.actionTrendList.triggered.connect(self.PrintTrendsList)
        self.actionTrendSet.triggered.connect(self.SetMSTATrendCases)
        self.actionModifyVariables.triggered.connect(self.ModifyVariables)
        self.actionDeleteVariables.triggered.connect(self.DeleteOneVariable)
        #  self.actionResetInitial.triggered.connect(self.resetInitialVariables)
        self.actionDeleteAllTrends.triggered.connect(self.DeleteAllTrends)
        self.actionComputeMSTA.triggered.connect(self.ComputeMSTA)

        self.setGeometry(10, 10, 400, 400)
        self.setWindowTitle('Multi Sediment Trend Analysis')

        self.menuVariables.setEnabled(False)
        self.menuTrends.setEnabled(False)
        self.actionGSTALikeTrend.setEnabled(False)
        self.computeMSTA.setEnabled(False)

        # Variables
        self.iface = _iface
        self.workingDir = os.path.expanduser("~")
        self.points = []
        # A list of all the variables in the current dataset
        self.totalVariablesName = []
        # A list of all the variables objects of class mstaVariable
        self.variablesObjectsList = []
        # The list of the current selected variable names, i.e. the working variables
        self.selectedVariableNames = []
        # A dict defining the three GSTA variables on the current dataset
        self.GSTAVariables = {'mean':'','sorting':'','skewness':''}
        # The current trend case(s) object
        self.trendCases = mstaComposedTrendCase()
        # "Central Widget" expands to fill all available space
        self.textwidget = QTextEdit()
        self.setCentralWidget(self.textwidget)
        self.textwidget.setEnabled(True)
        self.textwidget.setTextColor(QColor("black"))
        fontWeight = self.textwidget.currentFont().weight()
        self.textwidget.setTabStopWidth(fontWeight)

    ###############################################
    def DisplayAboutMSTA(self):
        about=aboutMSTA()
        about.exec()

    ###############################################
    def SetWorkingDirectory(self):
        self.workingDir = QFileDialog.getExistingDirectory(self, self.workingDir, "Select working directory...", QFileDialog.ShowDirsOnly)

    ###############################################
    def DataFileImport(self):
        # Choice of the file name
        fullPathFileName,_= QFileDialog.getOpenFileName(self,"Open a data file", 
                                                self.workingDir,"Text file(s) (*.txt *.csv)")

        if os.path.isfile(fullPathFileName): 
            importDlg = pyMstaTextFileAnalysisDialog(fullPathFileName)
            if importDlg.exec_() == QDialog.Rejected:
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            if not importDlg.getVariableNameList():
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            try:
                # get the lists of information
                coordsids,coordsnames,varids,varnames=importDlg.getVariableNameList()
                # get the data (variables values)
                dataset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(varnames),
                                usecols=tuple(varids)
                                )
                # get the coordinates
                coordsset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(coordsnames),
                                usecols=tuple(coordsids)
                                )
                # QMessageBox.information(self, "Import data...", f'{dataset.shape[0]} rows have been imported.')
            except ValueError:
                QMessageBox.critical(self, "Load data file error", "An error occured while reading data file.\nNo data imported")
                return

        # Create a temporary layer and add it to the current project
        # Create the database use for computations
        try:
            self.CreateTemporaryLayer(dataset, varnames, coordsset, coordsnames, QFileInfo(fullPathFileName).baseName())
        except:
            QMessageBox.critical(self, "Temporary layer error", "An error occured while creating temporary layer.")
            return
        try:
            self.createPointDB(dataset, varnames, coordsset, coordsnames)
        except:
            QMessageBox.critical(self, "Database initialisation error", "An error occured during database creation")
            return

        # Save information before living, just de names, variables are not created yet
        self.totalVariablesName = varnames.copy()
        self.updateLogViewPort(6, f'{len(self.points)} points created')
        self.updateLogViewPort(1, self.totalVariablesName)
        # All variables are selected by default at the beginning
        self.selectedVariableNames = self.totalVariablesName.copy()
        # Data set is loaded, variables and trends can be manage
        self.menuVariables.setEnabled(True)
        self.menuTrends.setEnabled(True)
        return

    ###############################################
    # _dataset: np.array of n samples lines and m variables columns
    # _varnames: list of the variables names
    # _coordsnames: list of the two coordinates variables
    # _coordsset: np.array of n samples lines and two coordinates
    # _filename: name of the text file (without extension) which contains the original data
    def CreateTemporaryLayer(self, _dataset, _varnames, _coordsset, _coordsnames, _filename):
        # Selection of a reference system eventually different from the current project
        theProj = QgsProjectionSelectionDialog(self)
        theProj.setCrs(QgsProject.instance().crs())
        result = theProj.exec_()
        if result == QDialog.Rejected:
            QMessageBox.information(self, "Reference system", "Layer reference system is the same to the current project")
            URI=f'point?crs={QgsProject.instance().crs().authid()}'
        else:
            URI=f'point?crs={theProj.crs().authid()}'
        # create the temporary layer
        vl = QgsVectorLayer(URI, f'msta_{_filename}_Layer', "memory")
        pr = vl.dataProvider()
        
        # create fields
        for i in range(len(_varnames)):
            # TODO: modify this to manage various QVariant types: string, int and double
            pr.addAttributes([QgsField(_varnames[i], QVariant.Double)]) # double by default
            vl.updateFields() # tell the vector layer to fetch changes from the provider

        # add features
        for i in range(_dataset.shape[0]):
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(_coordsset[_coordsnames[0]][i],_coordsset[_coordsnames[1]][i])))
            # cast numpy.float64 so that it can store in a QVariant.Double
            fet.setAttributes(list(map(float, list(_dataset[i]))))
            pr.addFeatures([fet])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl.updateExtents()
        # Add the temporary layer to the current project
        QgsProject.instance().addMapLayer(vl)
        return

    ###############################################
    # _points: np.array of n samples lines and two coordinates
    # _variables: np.array of n samples lines and m variables columns
    # _coordnames: list of the two coordinates variables
    # _varnames: list of the variables names
    # The variable names and values are stored at each point location
    def createPointDB(self, _variables, _varnames, _points, _coordnames):
        # first loop over the points
        for i in range(_points.shape[0]):
            # mp is mstaPoint
            newpt = mp(_points[_coordnames[0]][i], _points[_coordnames[1]][i])
            newpt.setID(i+1)
            for j in range(len(_varnames)):
                # mv is mstaVariable
                newvar = mv()
                newvar.setID(j+1)
                newvar.setName(_varnames[j])
                newvar.setAlias(_varnames[j]) # Alias = name by default
                newvar.setUnit("%") # By default % unit
                newvar.setValue(_variables[i][j])
                newvar.setDg(0.0) # By default Dg is null
                newvar.setRange(0.0) # By default, no range
                newvar.setSearch(0.0,0.0) # By default omnidirectional
                newpt.addVariable(newvar)
            self.points.append(newpt)
        # As each point has the same variable list, the object list is equal to the list of the 1st point by default
        self.variablesObjectsList = self.points[0].getVariables().copy()

    ###############################################
    # Function to update the variables in the points database
    # _newValue : list of changes to apply in relation with _code
    # this function make the change(s) only on current selected variables.
    def updatePointsDB(self, _newValue):
        progress = QProgressDialog("Update points...", "Cancel", 0, len(self.points), self)
        progress.setWindowFlags(QtCore.Qt.Dialog | QtCore.Qt.FramelessWindowHint | QtCore.Qt.CustomizeWindowHint)
        progress.setModal(True)
        progress.setMinimumDuration(0)
        progress.setCancelButton(None)  # Remove the cancel button.
        # Changes are operate on all the points
        i = 0
        for p in self.points:
            i = i + 1
            progress.setValue(i)
            for newv in _newValue:
                p.updateVariable(newv)
        progress.close()
        return

    ###############################################
    # Add _text information on the viewport of the application
    # base on _context (see CONTEXTINFO dict definition)
    def updateLogViewPort(self, _context, _text):
        dt = datetime.now()
        self.textwidget.append(f'{dt.strftime("%d %b %Y, %H:%M:%S")}: {CONTEXTINFO[_context]}')
        if not _text:
            self.textwidget.append("\t------")
        if isinstance(_text, list):
            for i in _text:
                self.textwidget.append(f'{i.__repr__()}\n')
        else:
            self.textwidget.append(f'{_text.__repr__()}\n')

    ###############################################
    # Print the current defined variable(s)
    def PrintAllVariablesList(self):
        if not self.totalVariablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        # Print all the current loaded variables
        self.updateLogViewPort(1, self.variablesObjectsList)

    ###############################################
    # Print the current selected variable(s)
    def PrintSelectedVariablesList(self):
        if not self.selectedVariableNames:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        # Print the current selected variables
        self.updateLogViewPort(1, [v for v in self.variablesObjectsList if v.getName() in self.selectedVariableNames])

    ###############################################
    # Print the defined trend(s)
    def PrintTrendsList(self):
        if self.trendCases.getTrendCount() == 0:
            QMessageBox.information(self, "Trend case", "No trend case(s) defined yet.")
            return
        self.updateLogViewPort(2, self.trendCases.__repr__())

    ###############################################
    # Definition of the GSTA variables to use for mean, sorting and skewness
    def SetGSTAVariables(self):
        # Global variables should be defined
        if not self.totalVariablesName:
            QMessageBox.information(self, "Variable", "No variables loaded yet.")
            return
        # Check if previous GSTA variables definition exists
        if self.GSTAVariables['mean'] or self.GSTAVariables['sorting'] or self.GSTAVariables['skewness']:
            msg = "Previous definition exist:\nmean: {}\nsorting: {}\nskewness: {}\nDo you want to change ?".format(self.GSTAVariables['mean'],
                                                                                      self.GSTAVariables['sorting'],
                                                                                      self.GSTAVariables['skewness'])
            if QMessageBox.question(self, "GSTA Variables", msg) == QMessageBox.No:
                return
        # Launch the dialog for definition of GSTA variables
        dlg = setGSTAVariablesDlg(self.totalVariablesName)
        result = dlg.exec()
        if not result or not dlg.areGSTAVariablesSet():
            QMessageBox.information(self, "GSTA Variables", "No GSTA variables defined yet")
            self.updateLogViewPort(1, "No GSTA variables defined yet")
            return

        # Update/fill the dictionnary of GSTA variables links
        self.GSTAVariables['mean'] = dlg.getMeanVariableName()
        self.GSTAVariables['sorting'] = dlg.getSortingVariableName()
        self.GSTAVariables['skewness'] = dlg.getSkewnessVariableName()

        # Clear and update the names of the current selected variable name list
        self.selectedVariableNames.clear()
        self.selectedVariableNames.append(dlg.getMeanVariableName())
        self.selectedVariableNames.append(dlg.getSortingVariableName())
        self.selectedVariableNames.append(dlg.getSkewnessVariableName())

        # Update the global variable list (mstaVariable)
        gstaVariableList = dlg.getGSTAVariablesDefinitions()
        for lv in self.variablesObjectsList:
            for nv in gstaVariableList:
                if nv.getName() == lv.getName(): # Change only the variables used for GSTA
                    del self.variablesObjectsList[self.variablesObjectsList.index(lv)]
                    self.variablesObjectsList.append(nv)

        self.updatePointsDB(self.variablesObjectsList) # Update the corresponding variables at each points
        self.updateLogViewPort(5, self.selectedVariableNames)

        # GSTA variables are defined, trends can be manage
        self.actionGSTALikeTrend.setEnabled(True)

    ###############################################
    def SetClearText(self):
        self.textwidget.clear()

    ###############################################
    def ModifyVariables(self):
        # Get the name of the variable of interest from user (only cuurent selected variables are listed)
        variable, ok = QInputDialog.getItem(self, 'Modify a variable', 'Select a variable', self.selectedVariableNames, 0, False)
        if ok:
            for vol in self.variablesObjectsList:
                if vol.getName() == variable:
                    # Open dialog of variables settings
                    dlg = setMSTAVariableOptionDlg(vol)
                    ok = dlg.exec()
                    if ok:
                        # Update the list of all the mstaVariable
                        newVar = dlg.getVariableDefinition()
                        del self.variablesObjectsList[self.variablesObjectsList.index(vol)]
                        self.variablesObjectsList.append(newVar)
                        self.updatePointsDB(self.variablesObjectsList)  # Update the corresponding variables at each points
                        self.updateLogViewPort(1, "Variable {} has been modified.".format(variable))
                        return
        return

    ###############################################
    def DeleteOneVariable(self):
        # Get the name of the variableof interest from user
        variable, ok = QInputDialog.getItem(self, 'Delete a variable', 'Select a variable', self.totalVariablesName, 0,
                                            False)
        if ok:
            for vol in self.variablesObjectsList:
                if vol.getName() == variable:
                    if QMessageBox.question(self, "Variable", "Are you sure you want to delete variable {} ?".format(variable)) == QMessageBox.Yes:
                        # Delete the variable name only from selected variable name list, variableObjectsList is not modified
                        del self.selectedVariableNames[self.selectedVariableNames.index(variable)]
                        self.updateLogViewPort(1, "Variable {} has been delete.".format(variable))
                    break

    '''
    ###############################################
    def resetInitialVariables(self):
        if QMessageBox.question(self, "Variable",
                                "Are you sure you want to reinitilized to initial variable set ?") == QMessageBox.Yes:
            # Retreive initial variable name list
            self.selectedVariableNames.clear()
            assert len(self.totalVariablesName) > 0
            self.selectedVariableNames = self.totalVariablesName.copy()
            # Reinitialized the list of variable objects to variables contained in initial dataset
            self.variablesObjectsList.clear()
            self.variablesObjectsList = self.points[0].getVariables().copy()
            self.updatePointsDB(self.variablesObjectsList)  # Update the corresponding variables at each points
            # In case GSTA variables were previously defined, it is reset
            self.GSTAVariables = {'mean': '', 'sorting': '', 'skewness': ''}
            # Print information
            self.updateLogViewPort(1, "Variables list has been set to initial to default current dataset.")
            self.updateLogViewPort(1, self.variablesObjectsList)
    '''
    ###############################################
    # Definition of the trend case(s) for a GSTA analysis
    def SetGSTATrendCases(self):
        dlg = setGSTATrendCasesDlg(self.selectedVariableNames, self.variablesObjectsList, self.trendCases)
        result = dlg.exec()
        if result and dlg.getTrendCases().getTrendCount() > 0:
            self.trendCases = dlg.getTrendCases()
            if len(self.selectedVariableNames) == 0 or \
                    self.GSTAVariables['mean'] == "" or \
                    self.GSTAVariables['sorting'] == "" or \
                    self.GSTAVariables['skewness'] == "":
                msg = "You just defined GSTA trend case(s) to study.\n" \
                      "You have now to defined the corresponding GSTA variables to use\n for mean, sorting and skewness"
                QMessageBox.information(self, "GSTA Variables", msg)
            else:
                # TODO: gérer la mise a jour de l'operand de chaque variable en fonction des cas choisis
                 return

    ###############################################
    def SetMSTATrendCases(self):
        dlg = setMSTATrendCasesDlg(self.selectedVariableNames, self.variablesObjectsList, self.trendCases) # Variable definition is the same for all points
        result = dlg.exec()
        if result:
            self.trendCases = dlg.getTrendCases()
            self.computeMSTA.setEnabled(True)
            return

    ###############################################
    def DeleteAllTrends(self):
        if self.trendCases.getTrendCount() == 0:
            QMessageBox.information(self, "Trend case(s)", "No trend case(s) defined yet.")
            return
        if QMessageBox.question(self, "Trend cases(s)", "Are you sure you want to delete all defined trends ?") == QMessageBox.Yes:
            self.trendCases = mstaComposedTrendCase()
            self.computeMSTA.setEnabled(False)
        return

    def ComputeMSTA(self):
        QMessageBox.information(self, "*/*\*/*\*", "Not implemented yet")
        return