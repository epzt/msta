# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mstaDialog
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np

from PyQt5 import uic
from PyQt5.QtWidgets import QMainWindow, QAction, QApplication, QDialog, QDockWidget, QTextEdit, QInputDialog
from PyQt5.QtGui import QFileDialog, QMessageBox, QColor
from PyQt5.QtCore import QVariant, QFileInfo

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

from .pyMstaTextFileAnalysisDialog import pyMstaTextFileAnalysisDialog
from .mstaCoreClass import mstaPoint as mp
from .mstaCoreClass import mstaVariable as mv
from .ui_about_msta import Ui_AboutDlg as AboutDlg

CONTEXTINFO = {1:"Variable(s) information", 2:"Trend(s) information", 3:"GSTA variable information", 4:"GSTA trend(s) information"}

Ui_MainWindow, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui_multi_sediment_trend_analysis_dialog_base.ui'))


class mstaDialog(QMainWindow, Ui_MainWindow):
    def __init__(self, _iface, parent=None):
        """Constructor."""
        super(mstaDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)             
        
        # Actions management
        self.actionAppQuit.triggered.connect(self.close)
        self.actionFileImport.triggered.connect(self.DataFileImport)
        self.actionAbout.triggered.connect(self.DisplayAboutMSTA)
        self.actionSetWorkingDirectory.triggered.connect(self.SetWorkingDirectory)
        self.actionVariableListAll.triggered.connect(self.VariablesListAll)
        self.actionSelectVariables.triggered.connect(self.SelectVariables)
        self.actionGSTALikeVariable.triggered.connect(self.SetGSTAVariables)
        self.actionClearViewText.triggered.connect(self.SetClearText)
        self.actionTrendList.triggered.connect(self.TrendsListAll)

        self.setGeometry(10, 10, 400, 400)
        self.setWindowTitle('Multi Sediment Trend Analysis') 

        # Variables
        self.iface = _iface
        self.workingDir = os.path.expanduser("~")
        self.points = []
        self.variablesName = []
        self.textwidget = QTextEdit()
        # "Central Widget" expands to fill all available space
        self.setCentralWidget(self.textwidget)
        self.textwidget.setEnabled(False)
        self.textwidget.setTextColor(QColor("black"))
        fontWeight = self.textwidget.currentFont().weight()
        self.textwidget.setTabStopWidth(fontWeight )
        #self.dataset = np.zeros((1,1)) # Just for initialisation
        #self.coordsset = np.zeros((1,1)) # Just for initialisation
        self.selectedVariables = []

    def DisplayAboutMSTA(self):
        AboutDlg().exec_()

    def SetWorkingDirectory(self):
        self.workingDir = QFileDialog.getExistingDirectory(self, self.workingDir, "Select working directory...", QFileDialog.ShowDirsOnly)

    def DataFileImport(self):
        # Choice of the file name
        fullPathFileName,_= QFileDialog.getOpenFileName(self,"Open a data file", 
                                                self.workingDir,"Text file(s) (*.txt *.csv)")

        if os.path.isfile(fullPathFileName): 
            importDlg = pyMstaTextFileAnalysisDialog(fullPathFileName)
            if importDlg.exec_() == QDialog.Rejected:
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            if not importDlg.getVariableNameList():
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            try:
                # get the lists of information
                coordsids,coordsnames,varids,varnames=importDlg.getVariableNameList()
                # get the data (variables values)
                dataset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(varnames),
                                usecols=tuple(varids)
                                )
                # get the coordinates
                coordsset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(coordsnames),
                                usecols=tuple(coordsids)
                                )
                QMessageBox.information(self, "Import data...", f'{dataset.shape[0]} rows have been imported.')
            except ValueError:
                QMessageBox.critical(self, "Load data file error", "An error occured while reading data file.\nNo data imported")
                return

        # Create a temporary layer and add it to the current project
        # Create the database use for computations
        try:
            self.CreateTemporaryLayer(dataset, varnames, coordsset, coordsnames, QFileInfo(fullPathFileName).baseName())
        except:
            QMessageBox.critical(self, "Temporary layer error", "An error occured while creating temporary layer.")
            return
        try:
            self.createDB(dataset, varnames, coordsset, coordsnames)
        except:
            QMessageBox.critical(self, "Database initialisation error", "An error occured during database creation")
            return

        # Save information before living
        self.variablesName = varnames

        return

    # _dataset: np.array of n samples lines and m variables columns
    # _varnames: list of the variables names
    # _coordsnames: list of the two coordinates variables
    # _coordsset: np.array of n samples lines and two coordinates
    # _filename: name of the text file (without extension) which contains the original data
    def CreateTemporaryLayer(self, _dataset, _varnames, _coordsset, _coordsnames, _filename):
        # create the temporary layer
        URI=f'point?crs={QgsProject.instance().crs().authid()}'
        vl = QgsVectorLayer(URI, f'msta_{_filename}_Layer', "memory")
        pr = vl.dataProvider()
        
        # create fields
        for i in range(len(_varnames)):
            # TODO: modify this to manage various QVariant types: string, int and double
            pr.addAttributes([QgsField(_varnames[i], QVariant.Double)]) # double by default
            vl.updateFields() # tell the vector layer to fetch changes from the provider

        # add features
        for i in range(_dataset.shape[0]):
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(_coordsset[_coordsnames[0]][i],_coordsset[_coordsnames[1]][i])))
            # cast numpy.float64 so that it can store in a QVariant.Double
            fet.setAttributes(list(map(float, list(_dataset[i]))))
            pr.addFeatures([fet])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl.updateExtents()
        # Add the temporary layer to the current project
        QgsProject.instance().addMapLayer(vl)

        return

    # _points: np.array of n samples lines and two coordinates
    # _variables: np.array of n samples lines and m variables columns
    # _coordnames: list of the two coordinates variables
    # _varnames: list of the variables namess
    def createDB(self, _variables, _varnames, _points, _coordnames):
        # first loop over the points
        for i in range(_points.shape[0]):
            # mp is mstaPoint
            newpt = mp(_points[_coordnames[0]][i], _points[_coordnames[1]][i])
            newpt.setID(i+1)
            for j in range(len(_varnames)):
                # mv is mstaVariable
                newvar = mv()
                newvar.setID(j+1)
                newvar.setName(_varnames[j])
                newvar.setUnit('')
                newvar.setValue(_variables[i][j])
                newvar.setRange(0.0,0.0)
                newpt.addVariable(newvar)
            self.points.append(newpt)

    # Add _text information on the viewport of the application
    # base on _context (see CONTEXTINFO dict definition)
    def updateLogViewPort(self, _context, _text):
        self.textwidget.append(f'{CONTEXTINFO[_context]}:')
        if not _text:
            self.textwidget.append("\tNone")
        if isinstance(_text, list):
            for i in _text:
                self.textwidget.append(f'\t{i}')
        else:
            self.textwidget.append(f'\t{_text}')

    def VariablesListAll(self):
        #if not self.variablesName:
        #    QMessageBox.information(self, "Variable", "No variables defined yet.")
        #    return

        # Create text entry box
        #text_edit_widget = QPlainTextEdit()
        #text_edit_widget = QTextEdit()

        # Change font, colour of text entry box
        #text_edit_widget.setStyleSheet(
        #        """QPlainTextEdit {background-color: #333;
        #        color: #00FF00;
        #        text-decoration: underline;
        #        font-family: Courier;}""")

        # "Central Widget" expands to fill all available space
        #self.setCentralWidget(text_edit_widget)

        # Print text to console whenever it changes
        #text_edit_widget.textChanged.connect(
        #        lambda: print(text_edit_widget.document().toPlainText()))

        self.updateLogViewPort(1, self.variablesName)
        # Set initial value of text
        #self.textwidget.setText(f'{[i for i in self.variablesName]}\n')

    def TrendsListAll(self):
        self.updateLogViewPort(2, self.variablesName)
    # Select one variable in the cuurent variable list and retunr it
    def SelectVariables(self):
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        theSelectedVarDlg = QInputDialog(self)
        theSelectedVarDlg.setCancelButtonText("Cancel")
        theSelectedVarDlg.setOkButtonText("Select")
        theSelectedVarDlg.setOption(QInputDialog.UseListViewForComboBoxItems)
        theSelectedVar, ok = theSelectedVarDlg.getItem(self,"Selection","Select a variable",self.variablesName)
        if ok and theSelectedVar:
            self.selectedVariables.append(theSelectedVar)

    def SetGSTAVariables(self):
        return

    def SetClearText(self):
        self.textwidget.clear()