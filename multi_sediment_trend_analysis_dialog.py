# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mstaDialog
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np

from PyQt5 import uic
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

from .pyMstaTextFileAnalysisDialog import pyMstaTextFileAnalysisDialog
from .mstaCoreClass import mstaPoint as mp
from .mstaCoreClass import mstaVariable as mv
from .mstaCoreClass import mstaTrendCase as trend
from .mstaCoreClass import mstaComposedTrendCase as cpdtrend
from .mstaUtilsClass import *


CONTEXTINFO = {1:"Variable(s) information", \
               2:"Trend(s) information", \
               3:"GSTA variable information", \
               4:"GSTA trend(s) information", \
               5:"Current selected variable", \
               6:"Points information", \
               999:""}

# constante definitions
UPDATEDB = {'varalias' : 0, \
            'varrange' : 1, \
            'varvalue' : 2, \
            'vartrend' : 3, \
            'varsearch' : 4}

Ui_MainWindow, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui_multi_sediment_trend_analysis_dialog_base.ui'))


class mstaDialog(QMainWindow, Ui_MainWindow):
    def __init__(self, _iface, parent=None):
        """Constructor."""
        super(mstaDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)             
        
        # Actions management
        self.actionAppQuit.triggered.connect(self.close)
        self.actionFileImport.triggered.connect(self.DataFileImport)
        self.actionAbout.triggered.connect(self.DisplayAboutMSTA)
        self.actionSetWorkingDirectory.triggered.connect(self.SetWorkingDirectory)
        self.actionVariableListAll.triggered.connect(self.PrintAllVariablesList)
        self.actionSelectOneVariable.triggered.connect(self.SelectOneVariable)
        self.actionSelectAllVariables.triggered.connect(self.SelectAllVariables)
        self.actionGSTALikeVariable.triggered.connect(self.SetGSTAVariables)
        self.actionGSTALikeTrend.triggered.connect(self.SetGSTATrends)
        self.actionClearViewText.triggered.connect(self.SetClearText)
        self.actionTrendList.triggered.connect(self.PrintTrendsList)

        self.setGeometry(10, 10, 400, 400)
        self.setWindowTitle('Multi Sediment Trend Analysis') 

        # Variables
        self.iface = _iface
        self.workingDir = os.path.expanduser("~")
        self.points = []
        # A list of all the variables in the current dataset
        self.variablesName = []
        # The list of the current selected variable names, i.e. the working variables
        self.selectedVariableNames = []
        # A dict defining the three GSTA variables on the current dataset
        self.GSTAVariables = {'mean':'','sorting':'','skewness':''}
        # The list of currend trend case(s)
        self.trendCases = []
        # "Central Widget" expands to fill all available space
        self.textwidget = QTextEdit()
        self.setCentralWidget(self.textwidget)
        self.textwidget.setEnabled(False)
        self.textwidget.setTextColor(QColor("black"))
        fontWeight = self.textwidget.currentFont().weight()
        self.textwidget.setTabStopWidth(fontWeight )


    def DisplayAboutMSTA(self):
        about=aboutMSTA()
        about.exec()

    def SetWorkingDirectory(self):
        self.workingDir = QFileDialog.getExistingDirectory(self, self.workingDir, "Select working directory...", QFileDialog.ShowDirsOnly)

    def DataFileImport(self):
        # Choice of the file name
        fullPathFileName,_= QFileDialog.getOpenFileName(self,"Open a data file", 
                                                self.workingDir,"Text file(s) (*.txt *.csv)")

        if os.path.isfile(fullPathFileName): 
            importDlg = pyMstaTextFileAnalysisDialog(fullPathFileName)
            if importDlg.exec_() == QDialog.Rejected:
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            if not importDlg.getVariableNameList():
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            try:
                # get the lists of information
                coordsids,coordsnames,varids,varnames=importDlg.getVariableNameList()
                # get the data (variables values)
                dataset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(varnames),
                                usecols=tuple(varids)
                                )
                # get the coordinates
                coordsset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(coordsnames),
                                usecols=tuple(coordsids)
                                )
                # QMessageBox.information(self, "Import data...", f'{dataset.shape[0]} rows have been imported.')
            except ValueError:
                QMessageBox.critical(self, "Load data file error", "An error occured while reading data file.\nNo data imported")
                return

        # Create a temporary layer and add it to the current project
        # Create the database use for computations
        try:
            self.CreateTemporaryLayer(dataset, varnames, coordsset, coordsnames, QFileInfo(fullPathFileName).baseName())
        except:
            QMessageBox.critical(self, "Temporary layer error", "An error occured while creating temporary layer.")
            return
        try:
            self.createDB(dataset, varnames, coordsset, coordsnames)
        except:
            QMessageBox.critical(self, "Database initialisation error", "An error occured during database creation")
            return

        # Save information before living, just de names, variables are not created yet
        self.variablesName = varnames.copy()
        self.updateLogViewPort(6, f'{len(self.points)} points created')
        self.updateLogViewPort(1, self.variablesName)
        # All variables are selected by default at the beginning
        self.selectedVariableNames = self.variablesName.copy()
        return

    # _dataset: np.array of n samples lines and m variables columns
    # _varnames: list of the variables names
    # _coordsnames: list of the two coordinates variables
    # _coordsset: np.array of n samples lines and two coordinates
    # _filename: name of the text file (without extension) which contains the original data
    def CreateTemporaryLayer(self, _dataset, _varnames, _coordsset, _coordsnames, _filename):
        # create the temporary layer
        URI=f'point?crs={QgsProject.instance().crs().authid()}'
        vl = QgsVectorLayer(URI, f'msta_{_filename}_Layer', "memory")
        pr = vl.dataProvider()
        
        # create fields
        for i in range(len(_varnames)):
            # TODO: modify this to manage various QVariant types: string, int and double
            pr.addAttributes([QgsField(_varnames[i], QVariant.Double)]) # double by default
            vl.updateFields() # tell the vector layer to fetch changes from the provider

        # add features
        for i in range(_dataset.shape[0]):
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(_coordsset[_coordsnames[0]][i],_coordsset[_coordsnames[1]][i])))
            # cast numpy.float64 so that it can store in a QVariant.Double
            fet.setAttributes(list(map(float, list(_dataset[i]))))
            pr.addFeatures([fet])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl.updateExtents()
        # Add the temporary layer to the current project
        QgsProject.instance().addMapLayer(vl)

        return

    # _points: np.array of n samples lines and two coordinates
    # _variables: np.array of n samples lines and m variables columns
    # _coordnames: list of the two coordinates variables
    # _varnames: list of the variables namess
    # The variable names and values are stored at each point location
    def createDB(self, _variables, _varnames, _points, _coordnames):
        # first loop over the points
        for i in range(_points.shape[0]):
            # mp is mstaPoint
            newpt = mp(_points[_coordnames[0]][i], _points[_coordnames[1]][i])
            newpt.setID(i+1)
            for j in range(len(_varnames)):
                # mv is mstaVariable
                newvar = mv()
                newvar.setID(j+1)
                newvar.setName(_varnames[j])
                newvar.setAlias(_varnames[j]) # Alias = name by default
                newvar.setUnit("other") # By default unknown unit
                newvar.setValue(_variables[i][j])
                newvar.setRange(_variables[i][j],_variables[i][j]) # By default, no range
                newpt.addVariable(newvar)
            self.points.append(newpt)

    # Add _text information on the viewport of the application
    # base on _context (see CONTEXTINFO dict definition)
    def updateLogViewPort(self, _context, _text):
        self.textwidget.append(f'{CONTEXTINFO[_context]}')
        if not _text:
            self.textwidget.append("\t------")
        if isinstance(_text, list):
            for i in _text:
                self.textwidget.append(f'\t{i}')
        else:
            self.textwidget.append(f'\t{_text}')

    # Print the current defined variable(s)
    def PrintAllVariablesList(self):
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        self.updateLogViewPort(1, self.variablesName)

    # Print the defined trend(s)
    def PrintTrendsList(self):
        if len(self.trendCases) == 0:
            QMessageBox.information(self, "Trend case", "No trend cae(s) defined yet.")
            return

        textInfo = []
        # As each point containts same variables, we use the first one as default: [0]
        for v in self.points[0].getVariablesName():
            if v.getName() in self.selectedVariableNames:
                newLine=f'{v.getAlias()}_i --- {v.getAlias()}_j'
                textInfo.append(newLine)
        self.updateLogViewPort(2, textInfo)

    # Select one variable in the current variable list
    def SelectOneVariable(self):
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        theSelectedVarDlg = QInputDialog(self)
        theSelectedVarDlg.setCancelButtonText("Cancel")
        theSelectedVarDlg.setOkButtonText("Select")
        theSelectedVarDlg.setOption(QInputDialog.UseListViewForComboBoxItems)
        theSelectedVar, ok = theSelectedVarDlg.getItem(self,"Selection","Select a variable",self.variablesName,0,False)
        if ok and theSelectedVar:
            self.selectedVariableNames.clear()
            self.updateLogViewPort(5, theSelectedVar)
            self.selectedVariableNames.append(theSelectedVar)

    # Select all the variables
    def SelectAllVariables(self):
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        self.updateLogViewPort(5, self.variablesName)
        self.selectedVariableNames.clear()
        self.selectedVariableNames = self.variablesName.copy()

    # Definition of the trend case(s) for a GSTA analysis
    def SetGSTATrends(self):
        dlg = setGSTATrendCases()
        result = dlg.exec()
        if result and len(dlg.trendCaseList) > 0:
            if len(self.selectedVariableNames) == 0:
                msg = "You just defined GSTA trend case(s) to study.\n" \
                      "You have now to defined the corresponding GSTA variables to use\n for mean, sorting and skewness"
                QMessageBox.information(self, "GSTA Variables", msg)
            else:
                # TODO: gérer la mise a jour de l'operand de chaque variable en fonction des cas choisis
                return

    # Definition of the GSTA variables to use for mean, sorting and skewness
    def SetGSTAVariables(self):
        # Global variables should be defined
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables loaded yet.")
            return
        # Check if previous GSTA variables definition exists
        if self.GSTAVariables['mean'] or self.GSTAVariables['sorting'] or self.GSTAVariables['skewness']:
            msg = "Previous definition exist:\nmean:{} sorting:{}, skewness:{}\nDo you want to change ?".format(self.GSTAVariables['mean'],
                                                                                      self.GSTAVariables['sorting'],
                                                                                      self.GSTAVariables['skewness'])
            if QMessageBox.information(self, "GSTA Variables", msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.No:
                return
        # Launch the dialog for definition of GSTA variables
        dlg = setGSTAVariables(self.variablesName)
        result = dlg.exec()
        if not result or not dlg.areGSTAVariablesSet():
            QMessageBox.information(self, "GSTA Variables", "No GSTA variables defined yet")
            return
        # Clear the names of the current variable list
        self.selectedVariableNames.clear()
        # construction of the new list of the working variable names
        self.selectedVariableNames.append(dlg.variablesDict['mean'])
        self.updatePointsDB(0, [dlg.variablesDict['mean'],'mean']) # Change of the alias over the points database
        self.selectedVariableNames.append(dlg.variablesDict['sorting'])
        self.updatePointsDB(0, [dlg.variablesDict['sorting'], 'sorting']) # Change of the alias over the points database
        self.selectedVariableNames.append(dlg.variablesDict['skewness'])
        self.updatePointsDB(0, [dlg.variablesDict['skewness'], 'skewness']) # Change of the alias over the points database
        self.updateLogViewPort(5, self.selectedVariableNames)

    def SetClearText(self):
        self.textwidget.clear()

    # Function to update the different parameters of the variables in the points database
    # _code : king of update to operate (see UPDATEDB definition)
    # _newvalue : list of changes to apply in relation with _code
    # this function make the change(s) only on current selected variables.
    def updatePointsDB(self, _code, _newvalue):
        progress = QProgressDialog("Update points...", "Cancel", 0, len(self.points), self)
        progress.setWindowFlags(QtCore.Qt.Dialog | QtCore.Qt.FramelessWindowHint | QtCore.Qt.CustomizeWindowHint)
        progress.setModal(True)
        progress.setMinimumDuration(0)
        progress.setCancelButton(None)  # Remove the cancel button.
        # Changes are operate on all the points
        i = 0
        for p in self.points:
            i = i + 1
            progress.setValue(i)
            if _code == UPDATEDB['varalias']:
                assert(len(_newvalue) == 2) # should have the variable name first and the new alias of this variable
                for v in p.variables:
                    if _newvalue[0] in self.selectedVariableNames:
                        v.setAlias(_newvalue[1])
                continue
            if _code == UPDATEDB['varrange']:
                assert (len(_newvalue) == 3)  # should have the variable name first and new min, max values of this variable
                for v in p.variables:
                    if _newvalue[0] in self.selectedVariableNames:
                        v.setRange(_newvalue[1], _newvalue[2])
                continue
        progress.close()
        return