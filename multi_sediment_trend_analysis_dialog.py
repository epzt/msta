# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mstaDialog
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np

from PyQt5 import uic
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

from .pyMstaTextFileAnalysisDialog import pyMstaTextFileAnalysisDialog
from .mstaCoreClass import mstaPoint as mp
from .mstaCoreClass import mstaVariable as mv
from .mstaCoreClass import mstaTrendCase as trend
from .mstaCoreClass import mstaComposedTrendCase as cpdtrend
from .mstaUtilsClass import *


CONTEXTINFO = {1:"Variable(s) information", 2:"Trend(s) information", 3:"GSTA variable information", 4:"GSTA trend(s) information"}

Ui_MainWindow, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui_multi_sediment_trend_analysis_dialog_base.ui'))


class mstaDialog(QMainWindow, Ui_MainWindow):
    def __init__(self, _iface, parent=None):
        """Constructor."""
        super(mstaDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)             
        
        # Actions management
        self.actionAppQuit.triggered.connect(self.close)
        self.actionFileImport.triggered.connect(self.DataFileImport)
        self.actionAbout.triggered.connect(self.DisplayAboutMSTA)
        self.actionSetWorkingDirectory.triggered.connect(self.SetWorkingDirectory)
        self.actionVariableListAll.triggered.connect(self.VariablesListAll)
        self.actionSelectVariables.triggered.connect(self.SelectVariables)
        self.actionGSTALikeVariable.triggered.connect(self.SetGSTAVariables)
        self.actionGSTALikeTrend.triggered.connect(self.SetGSTATrends)
        self.actionClearViewText.triggered.connect(self.SetClearText)
        self.actionTrendList.triggered.connect(self.TrendsListAll)

        self.setGeometry(10, 10, 400, 400)
        self.setWindowTitle('Multi Sediment Trend Analysis') 

        # Variables
        self.iface = _iface
        self.workingDir = os.path.expanduser("~")
        self.points = []
        # A list of all the variables in the current dataset
        self.variablesName = []
        # The list of the current used/selected variables
        self.selectedVariables = []
        # A dict defining the three GSTA variables on the current dataset
        self.GSTAVariables = {'mean':'','sorting':'','skewness':''}
        # "Central Widget" expands to fill all available space
        self.textwidget = QTextEdit()
        self.setCentralWidget(self.textwidget)
        self.textwidget.setEnabled(False)
        self.textwidget.setTextColor(QColor("black"))
        fontWeight = self.textwidget.currentFont().weight()
        self.textwidget.setTabStopWidth(fontWeight )
        #self.dataset = np.zeros((1,1)) # Just for initialisation
        #self.coordsset = np.zeros((1,1)) # Just for initialisation

    def DisplayAboutMSTA(self):
        about=aboutMSTA()
        about.exec()

    def SetWorkingDirectory(self):
        self.workingDir = QFileDialog.getExistingDirectory(self, self.workingDir, "Select working directory...", QFileDialog.ShowDirsOnly)

    def DataFileImport(self):
        # Choice of the file name
        fullPathFileName,_= QFileDialog.getOpenFileName(self,"Open a data file", 
                                                self.workingDir,"Text file(s) (*.txt *.csv)")

        if os.path.isfile(fullPathFileName): 
            importDlg = pyMstaTextFileAnalysisDialog(fullPathFileName)
            if importDlg.exec_() == QDialog.Rejected:
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            if not importDlg.getVariableNameList():
                QMessageBox.information(self, "Load data file", "No data imported.")
                return
            try:
                # get the lists of information
                coordsids,coordsnames,varids,varnames=importDlg.getVariableNameList()
                # get the data (variables values)
                dataset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(varnames),
                                usecols=tuple(varids)
                                )
                # get the coordinates
                coordsset = np.recfromtxt(fullPathFileName,
                                delimiter=importDlg.currentSeparator,
                                skip_header=importDlg.getNumberOfFirstLineToSkip(),
                                names=tuple(coordsnames),
                                usecols=tuple(coordsids)
                                )
                QMessageBox.information(self, "Import data...", f'{dataset.shape[0]} rows have been imported.')
            except ValueError:
                QMessageBox.critical(self, "Load data file error", "An error occured while reading data file.\nNo data imported")
                return

        # Create a temporary layer and add it to the current project
        # Create the database use for computations
        try:
            self.CreateTemporaryLayer(dataset, varnames, coordsset, coordsnames, QFileInfo(fullPathFileName).baseName())
        except:
            QMessageBox.critical(self, "Temporary layer error", "An error occured while creating temporary layer.")
            return
        try:
            self.createDB(dataset, varnames, coordsset, coordsnames)
        except:
            QMessageBox.critical(self, "Database initialisation error", "An error occured during database creation")
            return

        # Save information before living
        self.variablesName = varnames

        return

    # _dataset: np.array of n samples lines and m variables columns
    # _varnames: list of the variables names
    # _coordsnames: list of the two coordinates variables
    # _coordsset: np.array of n samples lines and two coordinates
    # _filename: name of the text file (without extension) which contains the original data
    def CreateTemporaryLayer(self, _dataset, _varnames, _coordsset, _coordsnames, _filename):
        # create the temporary layer
        URI=f'point?crs={QgsProject.instance().crs().authid()}'
        vl = QgsVectorLayer(URI, f'msta_{_filename}_Layer', "memory")
        pr = vl.dataProvider()
        
        # create fields
        for i in range(len(_varnames)):
            # TODO: modify this to manage various QVariant types: string, int and double
            pr.addAttributes([QgsField(_varnames[i], QVariant.Double)]) # double by default
            vl.updateFields() # tell the vector layer to fetch changes from the provider

        # add features
        for i in range(_dataset.shape[0]):
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(_coordsset[_coordsnames[0]][i],_coordsset[_coordsnames[1]][i])))
            # cast numpy.float64 so that it can store in a QVariant.Double
            fet.setAttributes(list(map(float, list(_dataset[i]))))
            pr.addFeatures([fet])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl.updateExtents()
        # Add the temporary layer to the current project
        QgsProject.instance().addMapLayer(vl)

        return

    # _points: np.array of n samples lines and two coordinates
    # _variables: np.array of n samples lines and m variables columns
    # _coordnames: list of the two coordinates variables
    # _varnames: list of the variables namess
    def createDB(self, _variables, _varnames, _points, _coordnames):
        # first loop over the points
        for i in range(_points.shape[0]):
            # mp is mstaPoint
            newpt = mp(_points[_coordnames[0]][i], _points[_coordnames[1]][i])
            newpt.setID(i+1)
            for j in range(len(_varnames)):
                # mv is mstaVariable
                newvar = mv()
                newvar.setID(j+1)
                newvar.setName(_varnames[j])
                newvar.setUnit('')
                newvar.setValue(_variables[i][j])
                newvar.setRange(0.0,0.0)
                newpt.addVariable(newvar)
            self.points.append(newpt)

    # Add _text information on the viewport of the application
    # base on _context (see CONTEXTINFO dict definition)
    def updateLogViewPort(self, _context, _text):
        self.textwidget.append(f'{CONTEXTINFO[_context]}:')
        if not _text:
            self.textwidget.append("\tNone")
        if isinstance(_text, list):
            for i in _text:
                self.textwidget.append(f'\t{i}')
        else:
            self.textwidget.append(f'\t{_text}')

    # Print the current defined variable(s)
    def VariablesListAll(self):
        self.updateLogViewPort(1, self.variablesName)

    # Print the defined trend(s)
    def TrendsListAll(self):
        varList = [self.GSTAVariables['mean'],self.GSTAVariables['sorting'],self.GSTAVariables['skewness']]
        self.updateLogViewPort(2, varList)

    # Select one variable in the current variable list and return it
    def SelectVariables(self):
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables defined yet.")
            return
        theSelectedVarDlg = QInputDialog(self)
        theSelectedVarDlg.setCancelButtonText("Cancel")
        theSelectedVarDlg.setOkButtonText("Select")
        theSelectedVarDlg.setOption(QInputDialog.UseListViewForComboBoxItems)
        theSelectedVar, ok = theSelectedVarDlg.getItem(self,"Selection","Select a variable",self.variablesName,0,False)
        if ok and theSelectedVar:
            self.selectedVariables.append(theSelectedVar)

    # Definition of the trend case(s) for a GSTA analysis
    def SetGSTATrends(self):
        dlg = setGSTATrendCases()
        result = dlg.exec()
        if result and len(dlg.trendCaseList) > 0:
            if len(self.selectedVariables) == 0:
                msg = "You just defined GSTA trend case(s) to study.\n" \
                      "You have now to defined the corresponding GSTA variables to use\n for mean, sorting and skewness"
                QMessageBox.information(self, "GSTA Variables", msg)
            else:
                # TODO: g√©rer la mise a jour de l'operand de chaque variable en fonction des cas choisis
                #for v in self.selectedVariables:
                return

    # Definition of the GSTA variables to use for mean, sorting and skewness
    def SetGSTAVariables(self):
        # Global variables should be defined
        if not self.variablesName:
            QMessageBox.information(self, "Variable", "No variables loaded yet.")
            return
        # Check if previous GSTA variables definition exists
        if self.GSTAVariables['mean'] or self.GSTAVariables['sorting'] or self.GSTAVariables['skewness']:
            msg = "Previous definition exist:\nmean:{} sorting:{}, skewness:{}\nDo you want to change ?".format(self.GSTAVariables['mean'],
                                                                                      self.GSTAVariables['sorting'],
                                                                                      self.GSTAVariables['skewness'])
            if QMessageBox.information(self, "GSTA Variables", msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.No:
                return
        # Launch the dialog for definition of GSTA variables
        dlg = setGSTAVariables(self.variablesName)
        result = dlg.exec()
        if not result or not dlg.areGSTAVariablesSet():
            QMessageBox.information(self, "GSTA Variables", "No GSTA variables defined yet")
            return
        # Treatment of the mean variable
        theNewVar = mv()
        theNewVar.setID(1) # Always ID 1 for mean variable
        theNewVar.setName(dlg.variablesDict['mean'])
        theNewVar.setRange(0.0,0.0) # No range by default
        self.selectedVariables.append(theNewVar)
        theNewVar = mv()
        theNewVar.setID(2)  # Always ID 2 for sorting variable
        theNewVar.setName(dlg.variablesDict['sorting'])
        theNewVar.setRange(0.0, 0.0)  # No range by default
        self.selectedVariables.append(theNewVar)
        theNewVar = mv()
        theNewVar.setID(3)  # Always ID 3 for skewness variable
        theNewVar.setName(dlg.variablesDict['skewness'])
        theNewVar.setRange(0.0, 0.0)  # No range by default
        self.selectedVariables.append(theNewVar)

    def SetClearText(self):
        self.textwidget.clear()