# -*- coding: utf-8 -*-
"""
/***************************************************************************
 msta
                                 A QGIS plugin
 Mutli-Sediment Trend Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import  (QRadioButton,
                              QMessageBox,
                              QDialog,
                              QInputDialog,
                              QCheckBox,
                              QGroupBox,
                              QVBoxLayout,
                              QGridLayout,
                              QDialogButtonBox,
                              QLineEdit,
                              QPushButton,
                              QHBoxLayout,
                              QTableWidget,
                              QTableWidgetItem)
from PyQt5.QtCore import QObject, pyqtSlot, Qt
import itertools as it
from functools import partial
from qgis.gui import QgsMapLayerComboBox,QgsMapCanvas
from qgis.core import QgsMapLayerProxyModel, QgsMapLayerType

from .ui_about_msta import Ui_AboutDlg
from .ui_set_gsta_variables_dialog import Ui_setGSTAVariablesDialog as setGSTAVarDlg
from .ui_gsta_trend_definition import Ui_setGSTATrendCaseDialog as setGSTATrendDlg
from .ui_msta_variable_definition import Ui_SetMSTAVarOptionsDlg as setMSTAVariableDlg
from .ui_msta_trend_definition import Ui_mstaTrendDefinitionDialog as setMSTATrendDlg
from .mstaCoreClass import mstaTrendCase, mstaComposedTrendCase, mstaVariable, mstaOperand
from . import config as cfg

#############################################################################
# Just a class to print About information
#############################################################################
class aboutMSTA(QDialog, Ui_AboutDlg):
    def __int__(self, parent=None):
        super(aboutMSTA,self).__init__(parent)
        self.setupUi(self)

#############################################################################
# GSTA variables definition from global variable list
#############################################################################
class setGSTAVariablesDlg(QDialog, setGSTAVarDlg):
    def __init__(self, _variablesList, parent=None):
        super(setGSTAVariablesDlg,self).__init__(parent)
        self.setupUi(self)

        self.meanComboBox.addItem('Choose a variable...')
        self.sortingComboBox.addItem('Choose a variable...')
        self.skewnessComboBox.addItem('Choose a variable...')
        # fill comboboxes with variables' names
        self.meanComboBox.addItems(_variablesList)
        self.sortingComboBox.addItems(_variablesList)
        self.skewnessComboBox.addItems(_variablesList)

        # currentTextChanged
        self.meanComboBox.activated.connect(self.getMean)
        self.sortingComboBox.activated.connect(self.getSorting)
        self.skewnessComboBox.activated.connect(self.getSkewness)

        # Initialisations
        self.items = _variablesList  # List of variable names
        self.variablesDefinition = [] # List of variable definitions (list of class mstaVariable)

    def getVariableDefinitionNames(self):
        return [v.getName() for v in self.variablesDefinition]

    def getVariableDefinitionAlias(self):
        return [v.getAlias() for v in self.variablesDefinition]

    def isVariableSet(self, _vname):
        return _vname in self.getVariableDefinitionNames()

    def isAliasSet(self, _valias):
        return _valias in self.getVariableDefinitionAlias()

    def getVariableDefinitionNameIndex(self, _vname):
        return self.getVariableDefinitionNames().index(_vname)

    def getVariableDefinitionAliasIndex(self, _vname):
        return self.getVariableDefinitionAlias().index(_vname)

    @pyqtSlot(int)
    def getMean(self, _index):
        item = self.meanComboBox.itemText(_index)
        if item == 'Choose a variable...' and self.isAliasSet('Mean'):
            varIndex = self.getVariableDefinitionAliasIndex('Mean')
            del self.variablesDefinition[varIndex]
            #return
        if self.isVariableSet(item):
            msg = "Variable {} is already used for {} parameter.\nDo you want to erase previous definition.".format(
                item, self.getVariableDefinitionAliasIndex(item))
            if QMessageBox.question(self, "GSTA Variables", msg) == QMessageBox.Yes:
                varIndex = self.getVariableDefinitionAliasIndex(item)
                del self.variablesDefinition[varIndex]

        #key = list(self.variablesDict.keys())[list(self.variablesDict.values()).index(item)]

        # Launch the dialog box of variable options definition
        variableDlg = setMSTAVariableOptionDlg(item)
        result = variableDlg.exec_()
        if not result:
            msg = "Mean variable not set."
            QMessageBox.information(self, "GSTA Variables", msg)
            return
        # Even if in variableDlg no definition is set for the mean variable, it is set to default values
        newVar = variableDlg.getVariableDefinition()
        # This is to force alias to have "Mean" value
        newVar.setAlias("Mean")
        self.variablesDefinition.append(newVar)

    @pyqtSlot(int)
    def getSorting(self, _index):
        item = self.sortingComboBox.itemText(_index)
        if item == 'Choose a variable...' and self.isAliasSet('Sorting'):
            varIndex = self.getVariableDefinitionAliasIndex('Sorting')
            del self.variablesDefinition[varIndex]
            #return
        if self.isVariableSet(item):
            msg = "Variable {} is already used for {} parameter.\nDo you want to erase previous definition.".format(
                item, self.getVariableDefinitionAliasIndex(item))
            if QMessageBox.question(self, "GSTA Variables", msg) == QMessageBox.Yes:
                varIndex = self.getVariableDefinitionAliasIndex(item)
                del self.variablesDefinition[varIndex]

        # Launch the dialog box of variable options definition
        variableDlg = setMSTAVariableOptionDlg(item)
        result = variableDlg.exec_()
        if not result:
            msg = "Sorting variable not set."
            QMessageBox.information(self, "GSTA Variables", msg)
            return
        # Even if in variableDlg no definition is set for the mean variable, it is set to default values
        newVar = variableDlg.getVariableDefinition()
        # This is to force alias to have "Sorting" value
        newVar.setAlias("Sorting")
        self.variablesDefinition.append(newVar)

    @pyqtSlot(int)
    def getSkewness(self, _index):
        item = self.skewnessComboBox.itemText(_index)
        if item == 'Choose a variable...' and self.isAliasSet('Skewness'):
            varIndex = self.getVariableDefinitionAliasIndex('Skewness')
            del self.variablesDefinition[varIndex]
            #return
        if self.isVariableSet(item):
            msg = "Variable {} is already used for {} parameter.\nDo you want to erase previous definition.".format(
                item, self.getVariableDefinitionAliasIndex(item))
            if QMessageBox.question(self, "GSTA Variables", msg) == QMessageBox.Yes:
                varIndex = self.getVariableDefinitionAliasIndex(item)
                del self.variablesDefinition[varIndex]

        # Launch the dialog box of variable options definition
        variableDlg = setMSTAVariableOptionDlg(item)
        result = variableDlg.exec_()
        if not result:
            msg = "Skewness variable not set."
            QMessageBox.information(self, "GSTA Variables", msg)
            return
        # Even if in variableDlg no definition is set for the mean variable, it is set to default values
        newVar = variableDlg.getVariableDefinition()
        # This is to force alias to have "Skewness" value
        newVar.setAlias("Skewness")
        self.variablesDefinition.append(newVar)

    def areAllGSTAVariablesSet(self):
        retValue  = False
        if self.getMeanVariableName() and self.getSortingVariableName() and self.getSkewnessVariableName():
            retValue = True
        return retValue

    def getMeanVariableName(self):
        try:
            id = self.getVariableDefinitionAliasIndex('Mean')
            return self.variablesDefinition[id]
        except:
            return ''

    def getSortingVariableName(self):
        try:
            id = self.getVariableDefinitionAliasIndex('Sorting')
            return self.variablesDefinition[id]
        except:
            return ''

    def getSkewnessVariableName(self):
        try:
            id = self.getVariableDefinitionAliasIndex('Skewness')
            return self.variablesDefinition[id]
        except:
            return ''

    def getGSTAVariablesDefinitions(self):
        return(self.variablesDefinition)

#############################################################################
# GSTA trend definition
#############################################################################
class setGSTATrendCasesDlg(QDialog, setGSTATrendDlg):
    def __init__(self, _variables, _trends, parent=None):
        super(setGSTATrendCasesDlg,self).__init__(parent)
        self.setupUi(self)
        # _variables should be a list of three mstaVariable objects
        assert isinstance(_variables, list) and len(_variables) >= 3
        assert isinstance(_variables[0], mstaVariable)
        # _trends must be of type mstaComposedTrendCase
        #assert isinstance(_trends, mstaComposedTrendCase)
        assert isinstance(_trends, list)
        # Assignements
        self.variables = _variables
        self.mainTrends = _trends  # mstaComposedTrendCase object(s)
        # Initial variables
        self.meanTrend = None
        self.sortingTrend = None
        self.skewnessTrend = None

        # In case there is/are trend(s) defined, set default operand
        #if self.mainTrends.getTrendCount() > 0:
        #if len(self.mainTrends) > 0:
        #    self.linkOperand = cfg.OPERAND['et'] # Default operand to link multiple GSTA trend case
        #    self.linkOperandComboBox.setCurrentText(cfg.OPERAND['et'])
        #    self.linkOperandComboBox.setEnabled(True)
        #else:
        #    self.linkOperand = cfg.OPERAND['none'] # No operand yet
        #    self.linkOperandComboBox.setCurrentText(cfg.OPERAND['none'])
        #    self.linkOperandComboBox.setEnabled(False)

        self.buttonAddGSTATrendCase.clicked.connect(self.addTrendCase)
        self.buttonRemoveGSTATrendCase.clicked.connect(self.removeGSTATrendCase)

        self.radioGSTAMeanFiner.toggled.connect(self.setMeanTrend)
        self.radioGSTAMeanCoarser.toggled.connect(self.setMeanTrend)
        self.radioGSTAMeanNone.toggled.connect(self.setMeanTrend)
        self.radioGSTASortingBetter.toggled.connect(self.setSortingTrend)
        self.radioGSTASortingPorer.toggled.connect(self.setSortingTrend)
        self.radioGSTASortingNone.toggled.connect(self.setSortingTrend)
        self.radioGSTASkewnessPlus.toggled.connect(self.setSkewnessTrend)
        self.radioGSTASkewnessMinus.toggled.connect(self.setSkewnessTrend)
        self.radioGSTASkewnessNone.toggled.connect(self.setSkewnessTrend)
        #self.linkOperandComboBox.currentTextChanged.connect(self.currentTextChanged)

        self.updateGSTATrendCasesText(self.mainTrends)

    ###############################################
    @pyqtSlot(bool)
    def setMeanTrend(self):
        self.meanTrend =  mstaTrendCase(self.getNameFromVariableList(self.variables, "Mean"), "none")
        if self.radioGSTAMeanFiner.isChecked():
            if self.meanTrend.getLeftVar().isMetric():
                self.meanTrend.setComp("sup")
            else:
                self.meanTrend.setComp("inf")
        elif self.radioGSTAMeanCoarser.isChecked():
            if self.meanTrend.getLeftVar().isMetric():
                self.meanTrend.setComp("inf")
            else:
                self.meanTrend.setComp("sup")
        else:
            self.meanTrend = None

    ###############################################
    @pyqtSlot(bool)
    def setSortingTrend(self):
        self.sortingTrend = mstaTrendCase(self.getNameFromVariableList(self.variables, "Sorting"), "none")
        if self.radioGSTASortingBetter.isChecked():
            self.sortingTrend.setComp("sup")
        elif self.radioGSTASortingPorer.isChecked():
            self.sortingTrend.setComp("inf")
        else:
            self.sortingTrend = None

    ###############################################
    @pyqtSlot(bool)
    def setSkewnessTrend(self):
        self.skewnessTrend = mstaTrendCase(self.getNameFromVariableList(self.variables, "Skewness"), "none")
        if self.radioGSTASkewnessPlus.isChecked():
            if self.skewnessTrend.getLeftVar().isMetric():
                self.skewnessTrend.setComp("sup")
            else:
                self.skewnessTrend.setComp("inf")
        elif self.radioGSTASkewnessMinus.isChecked():
            if self.skewnessTrend.getLeftVar().isMetric():
                self.skewnessTrend.setComp("inf")
            else:
                self.skewnessTrend.setComp("sup")
        else:
            self.skewnessTrend = None

    ###############################################
    # Add the new trend case to the main object
    @pyqtSlot(bool)
    def addTrendCase(self):
        # Two cases must defined at least to defined a new operand
        cList = [i for i in [self.meanTrend, self.sortingTrend, self.skewnessTrend] if i]
        # A GSTA trend inside a case is always linked by an AND operator
        if len(cList) == 2: # New combined trend case to add
            newCombinedTC = mstaComposedTrendCase(cList, \
                            [mstaOperand(cfg.OPERAND['et'], cList[0].getID(), cList[1].getID(), 0)])
        elif len(cList) == 3:
            newCombinedTC = mstaComposedTrendCase(cList, \
                            [mstaOperand(cfg.OPERAND['et'], cList[0].getID(), cList[1].getID(), 0), \
                             mstaOperand(cfg.OPERAND['et'], cList[1].getID(), cList[2].getID(), 0)])
        elif len(cList) == 1:
            newCombinedTC = mstaComposedTrendCase(cList[0])
        else:
            return # Nothing to create
        newCombinedTC.setComposedGSTATrend(True)  # It is a GSTA trend !! IMPORTANT TO SET IT AT TRUE
        #for tc in self.mainTrends.getTrend():
        for tc in self.mainTrends:
            if tc.isGSTATrend() and tc == newCombinedTC:  # Test if it is a GSTA trend
                return # The new GSTA trend was previously defined
        #self.mainTrends.addTrendCase(newCombinedTC, self.linkOperand)  # New GSTA trend case is added to the global object
        self.mainTrends.append(newCombinedTC)  # New GSTA trend case is added to the global object
        #self.linkOperand = cfg.OPERAND['et'] # Default operand to link multiple GSTA trend case
        #self.linkOperandComboBox.setCurrentText(cfg.OPERAND['et'])
        #self.linkOperandComboBox.setEnabled(True)
        self.updateGSTATrendCasesText(self.mainTrends)
        return

    ###############################################
    # Remove the current trend case to the main object
    @pyqtSlot(bool)
    def removeGSTATrendCase(self):
        # Current combined trend case object to remove
        currentCombinedTC = mstaComposedTrendCase([self.meanTrend, self.sortingTrend, self.skewnessTrend], cfg.OPERAND['et'])
        currentCombinedTC.setComposedGSTATrend(True)
        #for tc in self.mainTrends.getTrend():
        for tc in self.mainTrends:
            if tc.isGSTATrend():  # Test if it is a GSTA trend
                if tc == currentCombinedTC:  # The current GSTA trend is defined
                    self.mainTrends.remove(tc)  # The GSTA trend case is deleted of the global object
        #if self.mainTrends.getTrendCount() <= 0:
        #if len(self.mainTrends) == 0:
        #    self.linkOperandComboBox.setEnabled(False)
        self.updateGSTATrendCasesText(self.mainTrends)
        return

    ###############################################
    def updateGSTATrendCasesText(self, _theTrendCase):
        # Erase all previous text
        self.TrendCaseTextEdit.clear()
        # If no trends defined-> nothing to do
        #if _theTrendCase.getTrendCount() == 0:
        if len(_theTrendCase) == 0:
            return
        # Construction of the text
        textCasesTrend = ""
        #for tc in _theTrendCase.getTrend():
        for tc in _theTrendCase:
            if tc.isGSTATrend():
                textCasesTrend += tc.getGSTATrendText()
            else:
                textCasesTrend += (tc.__str__() + '\n')
        textCasesTrend += '\n'
        # Print the text in the widget
        self.TrendCaseTextEdit.setText(textCasesTrend)
        return

    ###############################################
    #def getGSTATrendCaseListNames(self):
        #if self.mainTrends.getTrendCount() > 0:
    #    if len(self.mainTrends) > 0:
    #        return [t.__str__() for t in self.mainTrends]
    #    else:
    #        return list()

    ###############################################
    def getTrendCases(self):
        # TODO: mettre à jour la liste des variables utilisées et la renvoyer
        return self.mainTrends

    ###############################################
    #@pyqtSlot('const QString')
    #def currentTextChanged(self, _text):
    #    self.linkOperand = _text

    ###############################################
    def getNameFromVariableList(self, _varList, _name):
        assert isinstance(_varList, list)
        for v in _varList:
            if v.getAlias() == _name:
                return v

    ###############################################
    def getSelectedMSTAVarnames(self):
        retValue = list()
        for tc in self.mainTrends:
            for vtc in tc.getVars():         # list(it.chain(*tc.getVars())): # Flatten the list of list in a list
                retValue.append(vtc.getName())
        return list(set(retValue)) # Allows to have unique element in the returned list

#############################################################################
# MSTA variable definition
#############################################################################
class setMSTAVariableOptionDlg(QDialog, setMSTAVariableDlg):
    def __init__(self, _variables, parent=None):
        super(setMSTAVariableOptionDlg, self).__init__(parent)
        self.setupUi(self)
        # Default unit
        self.unit = "%"
        self.aliasForced = False
        self.nameChanged = False
        self.variablesObjectsList = _variables  # List of all the variables defined
        self.variableNameComboBox.addItem("Choose a variable...")
        self.variableNameComboBox.addItems([v.getName() for v in self.variablesObjectsList])

        # Initialisation from previous variable
        self.variableDgLineEdit.setText("0.0")
        self.pmVariableRangeLineEdit.setText("0.0")
        self.directionSlider.setValue(0)
        self.majorAxisLineEdit.setText("0.0")
        self.minorAxisLineEdit.setText("0.0")
        self.variableUnitComboBox.setCurrentText(self.unit)

        # Connection définition
        self.variableUnitComboBox.currentTextChanged.connect(self.currentUnitChanged)
        self.variableNameComboBox.currentTextChanged.connect(self.variableNameChange)
        # Handle default Ok message
        self.buttonBox.accepted.connect(self.okBoutonGroupClicked)

    # Handle the ok button signal to verify that a variable name has been defined/chosen
    @pyqtSlot()
    def okBoutonGroupClicked(self):
        if self.variableNameComboBox.currentText() == "Choose a variable...":
            QDialog.reject(self)  # Quit the dialog as a Cancel operation
        else:
            QDialog.accept(self)

    @pyqtSlot('const QString')
    def currentUnitChanged(self, _unit):
        if _unit in cfg.UNIT.values():
            self.unit = _unit
            self.variableUnitComboBox.setCurrentIndex(self.variableUnitComboBox.findText(_unit))

    # Update fields of the dialog in case variable name change
    @pyqtSlot('const QString')
    def variableNameChange(self, _name):
        for v in self.variablesObjectsList:
            if v.getName() == _name:
                self.currentUnitChanged(v.getUnit())
                if not self.aliasForced:
                    self.variableAliasLineEdit.setText(v.getAlias())
                self.setVariableDg(v.getDg())
                self.setVariableRange(v.getRange())
                if not v.getSearch().isCircle():
                    self.anysotropyGroup.setChecked(True)
                    self.setVariableAnysotropy(v.getSearch())
                    self.setVariableDg(0.0)
                else:
                    self.anysotropyGroup.setChecked(False)
                    self.setVariableDg(v.getDg())
                self.nameChanged = True
                return

    def getVariableDefinition(self):
        newvar = mstaVariable()
        newvar.setName(self.getVariableName())
        newvar.setAlias(self.getVariableAlias())
        newvar.setUnit(self.getVariableUnit())
        if self.anysotropyGroup.isChecked():
            anysotropy = self.getVariableAnysotropy()
            newvar.setSearch(anysotropy[0], anysotropy[1], anysotropy[2]) # Ellipse
            newvar.setDg(0.0)
        else:
            newvar.setDg(self.getVariableDg())
            newvar.setSearch(self.getVariableDg(), self.getVariableDg(), 0.0) # Circle
        newvar.setRange(self.getVariableRange())
        return newvar

    def getVariableName(self):
        return self.variableNameComboBox.currentText()

    def getVariableAlias(self):
        return self.variableAliasLineEdit.text()

    def setVariableAlias(self, _alias):
        self.variableAliasLineEdit.setText(_alias)
        self.aliasForced = True

    def getVariableUnit(self):
        return self.unit

    def getVariableDg(self):
        return float(self.variableDgLineEdit.text())

    def setVariableDg(self, _dg):
        self.variableDgLineEdit.setText(str(_dg))

    def getVariableRange(self):
        return float(self.pmVariableRangeLineEdit.text())

    def setVariableRange(self, _range):
        self.pmVariableRangeLineEdit.setText(str(_range))

    def getVariableAnysotropy(self):
        return [float(self.majorAxisLineEdit.text()), float(self.minorAxisLineEdit.text()), float(self.directionSlider.value())]

    def setVariableAnysotropy(self, _anisotropy):
        self.majorAxisLineEdit.setText(str(_anisotropy.getMajor()))
        self.minorAxisLineEdit.setText(str(_anisotropy.getMinor()))
        self.directionSlider.setValue(_anisotropy.getDirection())

#############################################################################
# MSTA trend definition
#############################################################################
class setMSTATrendCasesDlg(QDialog, setMSTATrendDlg):
    def __init__(self, _variables, _trends, parent=None):
        super(setMSTATrendCasesDlg, self).__init__(parent)
        self.setupUi(self)
        # _variables should be a list of mstaVariable objects
        assert isinstance(_variables, list)
        assert isinstance(_variables[0], mstaVariable)
        # _trends must be of type mstaComposedTrendCase
        #assert isinstance(_trends, mstaComposedTrendCase)
        assert isinstance(_trends, list)
        # Construct the variable names list
        self.varObjectsList = _variables.copy()
        self.varNames = [v.getName() for v in self.varObjectsList]
        # Composed trend case object (contains all the other case)
        self.mainTrends = _trends
        # Update the text of defined trend cases
        self.updateMSTATrendCaseText(self.mainTrends)

        # Initialisations
        # Lists of comboboxes
        self.variableAComboBox.addItems(self.varNames)
        self.variableBComboBox.addItems(self.varNames)
        self.variableAName = self.variableAComboBox.currentText()
        self.variableBName = self.variableBComboBox.currentText()
        self.signType = self.comparatorComboBox.currentText()
        #self.linkOperand = self.linkOperandComboBox.currentText()

        self.clearPushButton.clicked.connect(self.ClearTrendListLabel)
        self.addPushButton.clicked.connect(self.addTrendCase)
        self.deletePushButton.clicked.connect(self.deleteTrendCase)
        self.variableAComboBox.currentTextChanged.connect(self.currentVariableATextChanged)
        self.variableBComboBox.currentTextChanged.connect(self.currentVariableBTextChanged)
        self.comparatorComboBox.currentTextChanged.connect(self.currentSignTextChanged)
        #self.linkOperandComboBox.currentTextChanged.connect(self.currentLinkOperandChanged)

    def getComp(self, _sign):
        assert _sign in cfg.COMP.values()
        return list(cfg.COMP.keys())[list(cfg.COMP.values()).index(_sign)]

    @pyqtSlot(bool)
    def ClearTrendListLabel(self):
        msg = 'Are you sure you want delete all trends ?'
        if QMessageBox.information(self, "MSTA Variables", msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.No:
            return
        self.trendCaseTextEdit.clear()
        #self.mainTrends = mstaComposedTrendCase()
        self.mainTrends = list()
        return

    @pyqtSlot(bool)
    def addTrendCase(self):
        # Two different variables can be mix only of they have same Dg or (direction, tolerance) and unit
        varA = self.varObjectsList[self.variableAComboBox.currentIndex()]
        varB = self.varObjectsList[self.variableBComboBox.currentIndex()]
        if not varA.isEqual(varB):
            QMessageBox.warning(self, "Trend definition error",
                                "Can\'t mix two variables with different characteristic distance, research angle, tolerance value or units:\n \
                                {}\n{}".format(varA.__repr__(), varB.__repr__()))
            return

        # Create a simple trend case
        if self.variableAName != self.variableBName: # In case varA is different to varB
            simpleCase = mstaTrendCase([varA, varB], self.getComp(self.signType))
        else:
            simpleCase = mstaTrendCase(varA, self.getComp(self.signType))
        # Create the new composed trend case to add to the list
        #if self.linkOperand == cfg.OPERAND['none']:
        newTrendCase = mstaComposedTrendCase(simpleCase)
        #else:
            #newTrendCase = mstaComposedTrendCase(simpleCase, self.linkOperand)
        newTrendCase.setComposedGSTATrend(False)
        #for tc in self.mainTrends.getTrend():
        for tc in self.mainTrends:
            if tc == newTrendCase:
                return
        # An operand must be set when adding more than one trend
        #if self.mainTrends.getTrendCount() > 0 and self.linkOperand == cfg.OPERAND['none']:
        #if len(self.mainTrends) > 0 and self.linkOperand == cfg.OPERAND['none']:
        #    QMessageBox.warning(self, "Trend definition error", \
        #                        "Two successive trends must be link with an operand\n \
        #                        Actual selected: {}\n".format(self.linkOperand))
        #    return
        # Add the new composed trend case to the global list
        #self.mainTrends.addTrendCase(newTrendCase, self.linkOperand)
        self.mainTrends.append(newTrendCase)
        # Update the text of defined trend cases
        self.updateMSTATrendCaseText(self.mainTrends)
        return

    @pyqtSlot(bool)
    def deleteTrendCase(self):
        varA = self.varObjectsList[self.variableAComboBox.currentIndex()]
        varB = self.varObjectsList[self.variableBComboBox.currentIndex()]
        # Create the current trend case
        if self.variableAName != self.variableBName:  # In case varA is different to varB
            simpleCase = mstaTrendCase([varA, varB], self.getComp(self.signType))
        else:
            simpleCase = mstaTrendCase(varA, self.getComp(self.signType))
        # Create composed trend case to delete from the list
        #trendCaseToDelete = mstaComposedTrendCase(simpleCase, self.linkOperand)
        trendCaseToDelete = mstaComposedTrendCase(simpleCase)
        #for t in self.mainTrends.getTrend():
        for tc in self.mainTrends:
            if tc == trendCaseToDelete:
                self.mainTrends.remove(tc)
        # Update the text of defined trend cases
        self.updateMSTATrendCaseText(self.mainTrends)
        return

    def updateMSTATrendCaseText(self, _theTrendCase):
        # Erase all previous text
        self.trendCaseTextEdit.clear()
        # Construction of the text
        textCasesTrend = ""
        #for tc in _theTrendCase.getTrend():
        for tc in _theTrendCase:
            if tc.isGSTATrend():
                textCasesTrend += tc.getGSTATrendText()
            else:
                textCasesTrend += (tc.__str__() + '\n')
        textCasesTrend += '\n'
        # Print the text in the widget
        self.trendCaseTextEdit.setText(textCasesTrend)
        return

    @pyqtSlot('const QString')
    def currentVariableATextChanged(self, _str):
        self.variableAName = _str
        self.variableBComboBox.setCurrentIndex(self.variableAComboBox.currentIndex())
        return

    @pyqtSlot('const QString')
    def currentVariableBTextChanged(self, _str):
        self.variableBName = _str
        return

    @pyqtSlot('const QString')
    def currentSignTextChanged(self, _str):
        self.signType = _str
        return

    #@pyqtSlot('const QString')
    #def currentLinkOperandChanged(self, _str):
    #    self.linkOperand = _str
    #    return

    def getSelectedMSTAVarnames(self):
        retValue = list()
        #for tc in self.mainTrends:
        #    for vtc in list(it.chain(*tc.getVars())): # Flatten the list of list in a list
        #        retValue.append(vtc.getName())
        for tc in self.mainTrends:
            for v in tc.getVars():
                retValue += v.getName()
        return retValue

    def getTrendCases(self):
        return self.mainTrends #, usedVariables

#############################################################################
# Variable selection dialog
#############################################################################
class setSelectedVariablesDlg(QDialog):
    def __init__(self, _variablesList, _currentSelectedList):
        super().__init__()
        self.vars = _variablesList
        self.selVars = _currentSelectedList
        self.varCheckBoxList = []
        self.buttonBox = QDialogButtonBox(self)
        self.windowLayout = QVBoxLayout()
        self.buttonBox.setStandardButtons(QDialogButtonBox.Ok)

        self.buttonBox.accepted.connect(self.accept)
        self.initUI()
        return

    def initUI(self):
        self.setWindowTitle("Selected variables")
        self.horizontalGroupBox = QGroupBox("Variables")
        self.layout = QGridLayout()
        self.layout.setColumnStretch(0,1)
        i = 0
        if len(self.selVars) > 0:
            for v in self.vars:
                cb = QCheckBox(v.getName())
                self.layout.addWidget(cb, i, 0)
                if v.getName() in self.selVars:
                    cb.setChecked(True)
                    self.varCheckBoxList.append(cb)
                i += 1
        else:
            for v in self.vars:
                cb = QCheckBox(v.getName())
                self.layout.addWidget(cb, i, 0)
                i += 1
                self.varCheckBoxList.append(cb)
        self.horizontalGroupBox.setLayout(self.layout)
        self.windowLayout.addWidget(self.horizontalGroupBox)
        self.windowLayout.addWidget(self.buttonBox)
        self.setLayout(self.windowLayout)

    def getSelectedVariables(self):
        retValue = []
        for i in range(self.layout.count()):
            if self.layout.itemAt(i).widget().isChecked():
                retValue.append(self.layout.itemAt(i).widget().text())
        return retValue

#############################################################################
# Class which mange trend to delete - created on the fly
#############################################################################
class DeleteTrendCaseDlg(QDialog):
    def __init__(self, _trendList, parent=None):
        super(DeleteTrendCaseDlg, self).__init__(parent)
        self.setWindowTitle("Delete trend case(s)")
        self.trendList = _trendList
        # Construction of the layout content
        self.gridLayout = QGridLayout()
        self.trendGroupBox = QGroupBox("Trend case list")
        self.tcLayout = QVBoxLayout()
        self.checkBoxTrendDict = dict()
        for tc in self.trendList:
            # Construction of the initial dictionary of checkboxes and IDs
            self.checkBoxTrendDict[tc.getID()] = QCheckBox(tc.__str__())
            self.tcLayout.addWidget(self.checkBoxTrendDict[tc.getID()])
        self.tcLayout.addStretch(1)
        self.trendGroupBox.setLayout(self.tcLayout)
        self.gridLayout.addWidget(self.trendGroupBox, 0, 0)
        self.undoButton = QPushButton("Undo")
        self.gridLayout.addWidget(self.undoButton, 0, 1)
        self.delButton = QPushButton("Delete selected")
        self.gridLayout.addWidget(self.delButton, 1, 0)
        #self.closeButton = QPushButton("Close")
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.gridLayout.addWidget(self.buttonBox, 2, 0)
        self.setLayout(self.gridLayout)
        # Variale declaration
        self.checkedTrendIDList = list()
        # Connections
        for k, cb in self.checkBoxTrendDict.items():
            cb.stateChanged.connect(partial(self.UpdateCheckedList, cb)) # Special syntax for parameter passing
        #self.closeButton.clicked.connect(self.close)
        self.delButton.clicked.connect(self.DeleteTrendCase)
        self.undoButton.clicked.connect(self.UndoLastDelete)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)

    # Check if almost one trend case is checked
    def IsTrendCaseChecked(self):
        for id, cb in self.checkBoxTrendDict.items():
            if cb.isChecked():
                return True
        return False

    @pyqtSlot(bool)
    def DeleteTrendCase(self):
        if not self.IsTrendCaseChecked():
            QMessageBox.information(self, "Delete trend case", "Not trend case selected.\nSelect at least one.")
            return
        #if len(self.checkedTrendIDList) == 0:
        #    QMessageBox.information(self, "Delete trend case", "Not trend case selected.\nSelect at least one.")
        #   return
        if QMessageBox.question(self, "Delete trend case", "Are you sure you want to delete trend case(s) ?") == QMessageBox.Yes:
            self.RefreshTrendCaseDlg()

    @pyqtSlot(bool)
    def UndoLastDelete(self):
        if len(self.checkedTrendIDList) == 0:
            return
        del self.checkedTrendIDList[-1]
        self.RefreshTrendCaseDlg()

    @pyqtSlot(QCheckBox)
    def UpdateCheckedList(self, _cb):
        keys = list(self.checkBoxTrendDict.keys())
        values = list(self.checkBoxTrendDict.values())
        id = keys[values.index(_cb)]
        #id = [k for (k, v) in self.checkBoxTrendDict.items() if v == _cb]
        if _cb.isChecked():
            if not id in self.checkedTrendIDList:
                self.checkedTrendIDList.append(id)
        else:
            if id in self.checkedTrendIDList:
                self.checkedTrendIDList.remove(id)

    def RefreshTrendCaseDlg(self):
        self.trendGroupBox.close()
        self.trendGroupBox = QGroupBox("Trend case list")
        self.tcLayout = QVBoxLayout()
        for tc in self.trendList:
            if not tc.getID() in self.checkedTrendIDList:
                self.tcLayout.addWidget(self.checkBoxTrendDict[tc.getID()])
        self.tcLayout.addStretch(1)
        self.trendGroupBox.setLayout(self.tcLayout)
        self.gridLayout.addWidget(self.trendGroupBox, 0, 0)
        # Just to be sure that on trend case is checked
        for id, cb in self.checkBoxTrendDict.items():
            if cb.isChecked() and not id in self.checkedTrendIDList:
                cb.setChecked(False)
        self.update()

    # Return the new trend case list
    def GetTrendCaseList(self):
        if len(self.checkedTrendIDList) == 0:
            return
        newTrendCaseList = list()
        for tc in self.trendList:
            if not tc.getID() in self.checkedTrendIDList:
                newTrendCaseList.append(tc)
        return newTrendCaseList

#############################################################################
# Class which allows to create the expression to be appied to the data set
#############################################################################
class SetMSTAExpressionDlg(QDialog):
    def __init__(self, _trendList, _expression=None, parent=None):
        super(SetMSTAExpressionDlg, self).__init__(parent)
        self.setWindowTitle("MSTA expression")
        self.trendList = _trendList
        self.checkedTrendIDList = list()
        # All the expression will be contained in an mstaComposedTrendCAse object
        if not _expression:
            self.mstaExpressionTrendCase = mstaComposedTrendCase()
        else:
            self.mstaExpressionTrendCase = _expression
        self.mstaExpressionOperand = None
        # Construction of the layout content
        self.gridLayout = QGridLayout()
        # Trend cases defined
        self.trendGroupBox = QGroupBox("Trend case list")
        self.tcLayout = QHBoxLayout()
        self.checkBoxTrendDict = dict()
        for tc in self.trendList:
            # Construction of the initial dictionary of checkboxes and IDs
            self.checkBoxTrendDict[tc.getID()] = QCheckBox(tc.__str__())
            self.tcLayout.addWidget(self.checkBoxTrendDict[tc.getID()])
        self.trendGroupBox.setLayout(self.tcLayout)
        self.scroll = QtWidgets.QScrollArea()
        self.scroll.setWidget(self.trendGroupBox)
        self.scroll.setWidgetResizable(True)
        self.scroll.setFixedWidth(500)
        self.gridLayout.addWidget(self.scroll, 0, 0)
        # Choice between the operands which are going to link trend cases
        self.operandGroupBox = QGroupBox("Link operands")
        self.operandLayout = QHBoxLayout()
        self.And = QRadioButton(cfg.OPERAND['et'])
        self.And.setChecked(True) # By default "And" is selected
        self.Or = QRadioButton(cfg.OPERAND['ou'])
        self.Xor = QRadioButton(cfg.OPERAND['xou'])
        self.operandLayout.addWidget(self.And)
        self.operandLayout.addWidget(self.Or)
        self.operandLayout.addWidget(self.Xor)
        self.operandGroupBox.setLayout(self.operandLayout)
        self.gridLayout.addWidget(self.operandGroupBox, 0, 1)
        # Buttons to manage trend case selections to set the expression
        self.addSetTrendCase = QPushButton("Add set")
        if len(self.trendList) <= 1:
            self.addSetTrendCase.setEnabled(False)
        self.addSingleTrendCase = QPushButton("Add single")
        if len(self.trendList) == 0:
            self.addSingleTrendCase.setEnabled(False)
        self.addOperand = QPushButton("Add")
        self.gridLayout.addWidget(self.addOperand, 1, 1)
        self.buttonAddLayout = QHBoxLayout()
        self.buttonAddLayout.addWidget(self.addSetTrendCase)
        self.buttonAddLayout.addWidget(self.addSingleTrendCase)
        self.gridLayout.addLayout(self.buttonAddLayout, 1, 0)
        # Buttons "Clear" and "Undo"
        self.buttonManageLayout = QVBoxLayout()
        self.clearTextEdit = QPushButton("Clear")
        self.undoTextEdit = QPushButton("Undo")
        self.buttonManageLayout.addWidget(self.undoTextEdit)
        self.buttonManageLayout.addWidget(self.clearTextEdit)
        self.gridLayout.addLayout(self.buttonManageLayout, 2, 1)
        # Text of the expression build using trend cases and operands
        self.expressionTextEdit = QtWidgets.QTextEdit()
        #self.expressionTextEdit.setAlignment(Qt.AlignCenter)
        self.expressionTextEdit.setUndoRedoEnabled(True)
        self.gridLayout.addWidget(self.expressionTextEdit, 2, 0)
        # Bottom buttons "Cancel", "Ok"
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.gridLayout.addWidget(self.buttonBox, 3, 1)
        self.setLayout(self.gridLayout)
        # Connections
        for k, cb in self.checkBoxTrendDict.items():
            cb.stateChanged.connect(partial(self.UpdateCheckedCaseList, cb)) # Special syntax for parameter passing
        self.addSetTrendCase.clicked.connect(self.AddSetTrendCase)
        self.addSingleTrendCase.clicked.connect(self.AddSingleTrend)
        self.addOperand.clicked.connect(self.AddOperand)
        #self.addOperand.setEnabled(False)
        self.clearTextEdit.clicked.connect(self.ClearTexEdit)
        #self.clearTextEdit.setEnabled(False)
        self.undoTextEdit.clicked.connect(self.UndoTextEdit)
        #self.undoTextEdit.setEnabled(False)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        # Update the dialog in case a previous expression was defined
        if self.mstaExpressionTrendCase.getTrendCount() > 0:  # A previous expression was defined
            self.expressionTextEdit.append(self.mstaExpressionTrendCase.__str__()) # Only one trend case
            self.addOperand.setEnabled(True)
            self.operandGroupBox.setEnabled(True)
            self.clearTextEdit.setEnabled(True)
            self.undoTextEdit.setEnabled(True)
            self.addSetTrendCase.setEnabled(False)
            self.addSingleTrendCase.setEnabled(False)
            self.trendGroupBox.setEnabled(False)
        else:  # No previous expression defined
            self.addOperand.setEnabled(False)
            self.operandGroupBox.setEnabled(False)
            self.clearTextEdit.setEnabled(False)
            self.undoTextEdit.setEnabled(False)
            self.addSetTrendCase.setEnabled(True)
            self.addSingleTrendCase.setEnabled(True)
            self.trendGroupBox.setEnabled(True)

    @pyqtSlot(bool)
    def ClearTexEdit(self):
        if QMessageBox.question(self,"Clear the expression", "Are you sure you want to erase all the expression ?") == QMessageBox.Yes:
            self.expressionTextEdit.clear()
            self.mstaExpressionTrendCase = mstaComposedTrendCase()
            self.mstaExpressionOperand = None
            self.undoTextEdit.setEnabled(False)
            self.clearTextEdit.setEnabled(False)
            self.addOperand.setEnabled(False)
            self.operandGroupBox.setEnabled(False)
            self.addSetTrendCase.setEnabled(True)
            self.addSingleTrendCase.setEnabled(True)
            self.trendGroupBox.setEnabled(True)

    @pyqtSlot(bool)
    def UndoTextEdit(self):
        self.expressionTextEdit.undo()
        if self.expressionTextEdit.document().isEmpty():
            self.undoTextEdit.setEnabled(False)
            self.clearTextEdit.setEnabled(False)
            self.addOperand.setEnabled(False)
            self.operandGroupBox.setEnabled(False)
            self.addSetTrendCase.setEnabled(True)
            self.addSingleTrendCase.setEnabled(True)
            self.trendGroupBox.setEnabled(True)
            self.mstaExpressionTrendCase = mstaComposedTrendCase()
            self.mstaExpressionOperand = None
            return
        if self.expressionTextEdit.document().lastBlock().text() in cfg.OPERAND.values():
            # The last trend case is deleted
            self.addOperand.setEnabled(False)
            self.operandGroupBox.setEnabled(False)
            self.addSetTrendCase.setEnabled(True)
            self.addSingleTrendCase.setEnabled(True)
            self.trendGroupBox.setEnabled(True)
            self.mstaExpressionTrendCase.deleteTrendCase(self.mstaExpressionTrendCase.getLastTrend())
        else:
            # The last operand is deleted
            self.addOperand.setEnabled(True)
            self.operandGroupBox.setEnabled(True)
            self.addSetTrendCase.setEnabled(False)
            self.addSingleTrendCase.setEnabled(False)
            self.trendGroupBox.setEnabled(False)
            self.mstaExpressionTrendCase.deleteOperand(self.mstaExpressionOperand)
            self.mstaExpressionOperand = None

    @pyqtSlot(QCheckBox)
    def UpdateCheckedCaseList(self, _cb):
        keys = list(self.checkBoxTrendDict.keys())
        values = list(self.checkBoxTrendDict.values())
        id = keys[values.index(_cb)]
        if _cb.isChecked():
            if not id in self.checkedTrendIDList:
                self.checkedTrendIDList.append(id)
        else:
            if id in self.checkedTrendIDList:
                self.checkedTrendIDList.remove(id)
        # Update buttons accessibility
        if len(self.checkedTrendIDList) > 1:
            self.addSingleTrendCase.setEnabled(False)
            self.addSetTrendCase.setEnabled(True)
        elif len(self.checkedTrendIDList) == 1:
            self.addSingleTrendCase.setEnabled(True)
            self.addSetTrendCase.setEnabled(False)
        else:
            self.addSingleTrendCase.setEnabled(False)
            self.addSetTrendCase.setEnabled(False)
        return

    @pyqtSlot(bool)
    def AddSetTrendCase(self):
        if len(self.checkedTrendIDList) == 0:
            QMessageBox.information(self, "Build expression", "No trend case selected.")
            return
        if len(self.checkedTrendIDList) == 1:
            QMessageBox.information(self, "Build expression", "Just one trend case selected.\nUse \"Add single\" button")
            return
        # Dialog to choose an operand to put between the trend cases
        opDlg = SetMSTAOperandDlg()
        if not opDlg.exec_():
            return
        selectedOPValue = opDlg.GetSelectedOperandValue()
        strToAdd = "("
        for id in self.checkedTrendIDList:
            strToAdd += f" {self.checkBoxTrendDict[id].text()}"
            if not id == self.checkedTrendIDList[-1]:
                strToAdd += f" {selectedOPValue}"
        strToAdd += " )"
        self.expressionTextEdit.append(strToAdd)
        self.undoTextEdit.setEnabled(True)
        self.clearTextEdit.setEnabled(True)
        self.addOperand.setEnabled(True)
        self.operandGroupBox.setEnabled(True)
        self.addSetTrendCase.setEnabled(False)
        self.addSingleTrendCase.setEnabled(False)
        self.trendGroupBox.setEnabled(False)
        # Construction of the list  of operands for the current composed trend case
        linkOP = list()
        for id in range(len(self.checkedTrendIDList)-1):
            linkOP.append(mstaOperand(selectedOPValue, self.checkedTrendIDList[id], self.checkedTrendIDList[id+1], 0))
        # Construction of the list of trend cases used for the current composed trend case
        trendCases = list()
        for tc in self.trendList:
            if tc.getID() in self.checkedTrendIDList:
                trendCases.append(tc)
        # Create a new composed trend case from the chosen ID trend case list
        newComposedTrend = mstaComposedTrendCase(trendCases, linkOP)
        # add the new trend case to the main (global) composed trend case
        self.mstaExpressionTrendCase.addTrendCase(newComposedTrend)
        if self.mstaExpressionOperand: # if a first trend case has been set for the current operand
            self.mstaExpressionOperand.setRightTrendID(self.mstaExpressionTrendCase.getLastTrend().getID()) # Set the second (last) ID
            self.mstaExpressionTrendCase.addOperand(self.mstaExpressionOperand) # Storage of the operand in the main composed trend case
            self.mstaExpressionOperand = None
        #self.mstaExpressionOperand = mstaOperand()  # Set to default, ready for next choice
        #self.mstaExpressionOperand.setLeftTrendID(self.mstaExpressionTrendCase.getLastTrend().getID())

    @pyqtSlot(bool)
    def AddSingleTrend(self):
        if len(self.checkedTrendIDList) == 0:
            QMessageBox.information(self, "Build expression", "No trend case selected.")
            return
        if len(self.checkedTrendIDList) > 1:
            QMessageBox.information(self, "Build expression", "To much trend cases selected.\nUse \"Add set\" button")
            return
        strToAdd = ""
        for id in self.checkedTrendIDList:
            strToAdd += f" {self.checkBoxTrendDict[id].text()}"
        self.expressionTextEdit.append(strToAdd)
        self.undoTextEdit.setEnabled(True)
        self.clearTextEdit.setEnabled(True)
        self.addOperand.setEnabled(True)
        self.operandGroupBox.setEnabled(True)
        self.addSetTrendCase.setEnabled(False)
        self.addSingleTrendCase.setEnabled(False)
        self.trendGroupBox.setEnabled(False)
        # Retreive the trend case from the chosen trend case list (normally with just one element)
        for tc in self.trendList:
            if tc.getID() == self.checkedTrendIDList[0]:
                newTrend = tc
        # add the new trend case to the main (global) composed trend case
        self.mstaExpressionTrendCase.addTrendCase(newTrend)
        if self.mstaExpressionOperand: # if a first trend case has been set previously for the current operand
            self.mstaExpressionOperand.setRightTrendID(self.mstaExpressionTrendCase.getLastTrend().getID())  # Set the second (last) ID
            self.mstaExpressionTrendCase.addOperand(self.mstaExpressionOperand)  # Storage of the operand in the main composed trend case
            self.mstaExpressionOperand = None
        #self.mstaExpressionOperand = mstaOperand()  # Set to default, ready for next choice
        #self.mstaExpressionOperand.setLeftTrendID(self.mstaExpressionTrendCase.getLastTrend().getID()) # Just set the first (left) trend case ID

    @pyqtSlot(bool)
    def AddOperand(self):
        assert self.mstaExpressionTrendCase.getTrendCount() >= 1
        self.undoTextEdit.setEnabled(True)
        self.addOperand.setEnabled(False)
        self.operandGroupBox.setEnabled(False)
        self.addSetTrendCase.setEnabled(True)
        self.addSingleTrendCase.setEnabled(True)
        self.trendGroupBox.setEnabled(True)
        self.mstaExpressionOperand = mstaOperand()  # Set to default, ready for next choice
        if self.And.isChecked():
            self.expressionTextEdit.append(cfg.OPERAND['et'])
            self.mstaExpressionOperand.setOP(cfg.OPERAND['et'])
        elif self.Or.isChecked():
            self.expressionTextEdit.append(cfg.OPERAND['ou'])
            self.mstaExpressionOperand.setOP(cfg.OPERAND['ou'])
        else:
            self.expressionTextEdit.append(cfg.OPERAND['xou'])
            self.mstaExpressionOperand.setOP(cfg.OPERAND['xou'])
        self.mstaExpressionOperand.setLeftTrendID(
            self.mstaExpressionTrendCase.getLastTrend().getID())  # Just set the first (left) trend case ID

    def GetMSTAExpressionTrendCase(self):
        res, msg  = self.mstaExpressionTrendCase.check()
        if not res:
            QMessageBox.information(self, "Invalid expression", msg)
        return self.mstaExpressionTrendCase

#############################################################################
# Class to allows to select an operand between "And", "Or" and "Xor"
#############################################################################
class SetMSTAOperandDlg(QDialog):
    def __init__(self, parent=None):
        super(SetMSTAOperandDlg, self).__init__(parent)
        self.setWindowTitle("MSTA expression")
        self.operandGroupBox = QGroupBox("")
        self.gridLayout = QGridLayout()
        self.labelText = QtWidgets.QLabel("Select an operand to insert between the trend cases:")
        self.gridLayout.addWidget(self.labelText, 0, 0, 1, -1)
        self.operandLayout = QHBoxLayout()
        self.And = QRadioButton(cfg.OPERAND['et'])
        self.And.setChecked(True) # By default "And" is selected
        self.Or = QRadioButton(cfg.OPERAND['ou'])
        self.Xor = QRadioButton(cfg.OPERAND['xou'])
        self.operandLayout.addWidget(self.And)
        self.operandLayout.addWidget(self.Or)
        self.operandLayout.addWidget(self.Xor)
        self.operandGroupBox.setLayout(self.operandLayout)
        self.gridLayout.addWidget(self.operandGroupBox, 1, 0, 1, -1)
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.gridLayout.addWidget(self.buttonBox, 2, 1)
        self.setLayout(self.gridLayout)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)

    def GetSelectedOperandValue(self):
        if self.And.isChecked():
            return cfg.OPERAND['et']
        elif self.Or.isChecked():
            return cfg.OPERAND['ou']
        else:
            return cfg.OPERAND['xou']

#############################################################################
# Class to select layer(s) used as barrier
#############################################################################
class SelectBarrierLayerDlg(QDialog):
    def __init__(self, canvas, barrierLayerList, parent=None):
        super(SelectBarrierLayerDlg, self).__init__(parent)
        self.setWindowTitle("MSTA barrier layer(s)")
        assert isinstance(canvas, QgsMapCanvas)
        assert isinstance(barrierLayerList, list)
        layers = canvas.layers()
        self.layersGroupBox = QGroupBox("Vector layer(s)")
        self.gridLayout = QGridLayout()
        self.layersLayout = QVBoxLayout()
        self.checkBoxLayerDict = dict()
        self.mapLayersDict = dict()
        for vl in layers:
            # Construction of the initial dictionary of checkboxes and IDs
            if vl.type() == QgsMapLayerType.VectorLayer:
                self.checkBoxLayerDict[vl.name()] = QCheckBox(vl.name())
                self.mapLayersDict[vl.name()] = vl
                if vl.name() in [bl.name() for bl in barrierLayerList]:
                    self.checkBoxLayerDict[vl.name()].setChecked(True)
                self.layersLayout.addWidget(self.checkBoxLayerDict[vl.name()])
        self.layersGroupBox.setLayout(self.layersLayout)
        self.gridLayout.addWidget(self.layersGroupBox, 0, 0)
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.gridLayout.addWidget(self.buttonBox, 1, 0)
        self.setLayout(self.gridLayout)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)

    # return a list of selected vector file layers
    def GetBarrierLIst(self):
        retValue = list()
        for key in self.checkBoxLayerDict:
            if self.checkBoxLayerDict[key].isChecked():
                retValue.append(self.mapLayersDict[key])
        return retValue

#############################################################################
# Class to visualize the value of the variables stored at each point
#############################################################################
class ViewDataBaseDlg(QDialog):
    def __init__(self, _pointsDB, parent=None):
        super(ViewDataBaseDlg, self).__init__(parent)
        assert isinstance(_pointsDB, list)
        self.setWindowTitle("Current data set")
        self.gridLayout = QGridLayout()
        self.tableWidget = QTableWidget(len(_pointsDB), len(_pointsDB[0].getVariables()))
        self.tableWidget.setHorizontalHeaderLabels([v.getAlias() for v in _pointsDB[0].getVariables()])
        l = 0
        for p in _pointsDB:
            c = 0
            for v in p.getVariables():
                newItem = QTableWidgetItem("{}".format(v.getValue()))
                self.tableWidget.setItem(l,c,newItem)
                c += 1
            l += 1
        self.gridLayout.addWidget(self.tableWidget, 0, 0)
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        self.gridLayout.addWidget(self.buttonBox, 1, 0)
        self.setLayout(self.gridLayout)
        self.buttonBox.accepted.connect(self.accept)

#############################################################################
# Class to store and manage results of MSTA computation
#############################################################################
class mstaResults():
    def __init__(self, _varname=None):
        if _varname:
            self.varname = _varname
        else:
            self.varname = ""
        self.usedNeighborPointCount = 0
        self.neighborPoint = list()
        self.easting = list()
        self.northing = list()
        self.distance = list()

    def __repr__(self):
        str = "\nVariable: {}\nNeighbor: {} (used)\nEasting: {}\nNorthing: {}\n" \
              "Distance: {}".format(self.varname,
                                    self.usedNeighborPointCount,
                                    self.easting,
                                    self.northing,
                                    self.distance)
        return str

    def SetVarname(self, _varname):
        self.varname = _varname

    def GetVarname(self):
        return self.varname

    def SetEasting(self, _value):
        assert isinstance(_value, float)
        self.easting.append(_value)

    def GetEasting(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.easting)
            return self.easting[_id]
        else:
            return sum(self.easting)

    def SetNorthing(self, _value):
        assert isinstance(_value, float)
        self.northing.append(_value)

    def GetNorthing(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.northing)
            return self.northing[_id]
        else:
            return sum(self.northing)

    def GetDistance(self, *args):
        if len(args) > 0:
            _id = args[0]  # args[0] is an integer
            assert _id < len(self.distance)
            return self.distance[_id]
        else:
            return sum(self.distance)

    def SetDistance(self, _value):
        assert isinstance(_value, float)
        self.distance.append(_value)

    def GetNeighborCount(self):
        return len(self.neighborPoint)

    def SetNeighborList(self, _nb):
        assert isinstance(_nb, list)
        self.neighborPoint = _nb

    def GetNeighborList(self):
        return self.neighborPoint

    def SetUsedNeighbor(self, _nbc):
        assert isinstance(_nbc, int)
        self.usedNeighborPointCount = _nbc

    def GetUsedNeighbor(self):
        return self.usedNeighborPointCount